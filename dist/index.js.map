{"mappings":"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","sources":["src/index.js","src/base/CityJSONLoader.js","src/parsers/CityObjectParser.js","src/parsers/CityJSONWorkerParser.js","src/defaults/colors.js","src/parsers/geometry/GeometryData.js","src/materials/CityObjectsMaterial.js","src/materials/CityObjectsBaseMaterial.js","src/objects/CityObjectsMesh.js","src/objects/CityObjectsLines.js","src/objects/CityObjectsPoints.js","src/materials/CityObjectsLineMaterial.js","src/materials/CityObjectsPointsMaterial.js","src/parsers/geometry/TriangleParser.js","src/parsers/geometry/BaseParser.js","src/parsers/geometry/LineParser.js","src/parsers/geometry/PointParser.js","src/objects/CityObjectsInstancedMesh.js","src/parsers/ObjectMaterialParser.js","src/parsers/helpers/ChunkParser.js","src/helpers/AttributeEvaluator.js","src/helpers/TextureManager.js"],"sourcesContent":["import { CityJSONLoader } from './base/CityJSONLoader.js';\nimport { CityJSONWorkerParser } from './parsers/CityJSONWorkerParser.js';\nimport { ObjectMaterialParser } from './parsers/ObjectMaterialParser.js';\nimport { ChunkParser } from './parsers/helpers/ChunkParser.js';\n\nimport { CityObjectsMesh } from './objects/CityObjectsMesh.js';\nimport { CityObjectsInstancedMesh } from './objects/CityObjectsInstancedMesh.js';\nimport { CityObjectsLines } from './objects/CityObjectsLines.js';\nimport { CityObjectsPoints } from './objects/CityObjectsPoints.js';\n\nimport { CityObjectsMaterial } from './materials/CityObjectsMaterial.js';\nimport { CityObjectsLineMaterial } from './materials/CityObjectsLineMaterial.js';\nimport { CityObjectsPointsMaterial } from './materials/CityObjectsPointsMaterial.js';\n\nimport { AttributeEvaluator } from './helpers/AttributeEvaluator.js';\nimport { TextureManager } from './helpers/TextureManager.js';\n\nexport {\n\tCityJSONLoader,\n\tCityJSONWorkerParser,\n\tObjectMaterialParser,\n\tChunkParser,\n\n\tCityObjectsInstancedMesh,\n\tCityObjectsMesh,\n\tCityObjectsLines,\n\tCityObjectsPoints,\n\n\tCityObjectsMaterial,\n\tCityObjectsLineMaterial,\n\tCityObjectsPointsMaterial,\n\n\tAttributeEvaluator,\n\tTextureManager\n};\n","import { Vector3 } from 'three';\nimport {\n\tBufferAttribute,\n\tBufferGeometry,\n\tGroup,\n\tMatrix4 } from 'three';\nimport { CityObjectParser } from '../parsers/CityObjectParser.js';\n\nexport class CityJSONLoader {\n\n\tconstructor( parser ) {\n\n\t\tthis.texturesPath = '';\n\t\tthis.scene = new Group();\n\t\tthis.matrix = null;\n\t\tthis.boundingBox = null;\n\t\tthis.parser = parser || new CityObjectParser();\n\n\t}\n\n\tsetTexturesPath( path ) {\n\n\t\tthis.texturesPath = path;\n\n\t}\n\n\tload( data ) {\n\n\t\tif ( typeof data === \"object\" ) {\n\n\t\t\t// We shallow clone the object to avoid modifying the original\n\t\t\t// objects vertices\n\t\t\tconst new_data = Object.assign( {}, data );\n\t\t\tnew_data.vertices = this.applyTransform( data );\n\n\t\t\tif ( this.matrix == null ) {\n\n\t\t\t\tthis.computeMatrix( new_data );\n\n\t\t\t}\n\n\t\t\tthis.parser.matrix = this.matrix;\n\t\t\tthis.parser.parse( new_data, this.scene );\n\n\t\t}\n\n\t}\n\n\tapplyTransform( data ) {\n\n\t\tif ( data[ \"transform\" ] != undefined ) {\n\n\t\t\tconst t = data.transform.translate;\n\t\t\tconst s = data.transform.scale;\n\n\t\t\tconst vertices = data.vertices.map( v =>\n\t\t\t\t[\n\t\t\t\t\tv[ 0 ] * s[ 0 ] + t[ 0 ],\n\t\t\t\t\tv[ 1 ] * s[ 1 ] + t[ 1 ],\n\t\t\t\t\tv[ 2 ] * s[ 2 ] + t[ 2 ]\n\t\t\t\t]\n\t\t\t);\n\n\t\t\treturn vertices;\n\n\t\t}\n\n\t\treturn data.vertices;\n\n\t}\n\n\t/**\n\t * Computes a matrix that transforms the dataset close to the origin.\n\t *\n\t * @param {Object} data The CityJSON data\n\t */\n\tcomputeMatrix( data, scale = false ) {\n\n\t\tconst normGeom = new BufferGeometry();\n\n\t\tconst vertices = new Float32Array( data.vertices.map( v => [ v[ 0 ], v[ 1 ], v[ 2 ] ] ).flat() );\n\t\tnormGeom.setAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n\n\t\tnormGeom.computeBoundingBox();\n\t\tthis.boundingBox = normGeom.boundingBox;\n\t\tconst centre = new Vector3();\n\n\t\tnormGeom.boundingBox.getCenter( centre );\n\t\tcentre.setZ( 0 );\n\t\t// const radius = normGeom.boundingSphere.radius;\n\n\t\t// const s = scale ? radius === 0 ? 1 : 1.0 / radius : 1;\n\t\tconst s = 1;\n\n\t\tconst matrix = new Matrix4();\n\t\tmatrix.set(\n\t\t\ts, 0, 0, - s * centre.x,\n\t\t\t0, s, 0, - s * centre.y,\n\t\t\t0, 0, s, - s * centre.z,\n\t\t\t0, 0, 0, 1\n\t\t);\n\n\t\tthis.matrix = matrix;\n\n\t}\n\n}\n","import {\n\t// Face3,\n\t// Geometry,\n\tMesh,\n\tMeshLambertMaterial,\n\tVector3 } from 'three';\nimport earcut from 'earcut';\n\nexport class CityObjectParser {\n\n\tconstructor() {\n\n\t\tthrow new Error( 'not supported anymore with this version of threejs' );\n\n\t\tthis.matrix = null;\n\n\t\tthis.objectColors = {\n\t\t\t\"Building\": 0x7497df,\n\t\t\t\"BuildingPart\": 0x7497df,\n\t\t\t\"BuildingInstallation\": 0x7497df,\n\t\t\t\"Bridge\": 0x999999,\n\t\t\t\"BridgePart\": 0x999999,\n\t\t\t\"BridgeInstallation\": 0x999999,\n\t\t\t\"BridgeConstructionElement\": 0x999999,\n\t\t\t\"CityObjectGroup\": 0xffffb3,\n\t\t\t\"CityFurniture\": 0xcc0000,\n\t\t\t\"GenericCityObject\": 0xcc0000,\n\t\t\t\"LandUse\": 0xffffb3,\n\t\t\t\"PlantCover\": 0x39ac39,\n\t\t\t\"Railway\": 0x000000,\n\t\t\t\"Road\": 0x999999,\n\t\t\t\"SolitaryVegetationObject\": 0x39ac39,\n\t\t\t\"TINRelief\": 0xffdb99,\n\t\t\t\"TransportSquare\": 0x999999,\n\t\t\t\"Tunnel\": 0x999999,\n\t\t\t\"TunnelPart\": 0x999999,\n\t\t\t\"TunnelInstallation\": 0x999999,\n\t\t\t\"WaterBody\": 0x4da6ff\n\t\t};\n\n\t}\n\n\t// parse( data, scene ) {\n\n\t// \tfor ( const objectId in data.CityObjects ) {\n\n\t// \t\tconst geom = this.parseObject( objectId, data );\n\n\t// \t\tconst objectType = data.CityObjects[ objectId ].type;\n\n\t// \t\tconst material = new MeshLambertMaterial();\n\t// \t\tmaterial.color.setHex( this.objectColors[ objectType ] );\n\n\t// \t\tconst mesh = new Mesh( geom, material );\n\t// \t\tmesh.name = objectId;\n\t// \t\tmesh.castShadow = true;\n\t// \t\tmesh.receiveShadow = true;\n\n\t// \t\tscene.add( mesh );\n\n\t// \t}\n\n\t// }\n\n\t// parseObject( objectId, json ) {\n\n\t// \tconst cityObject = json.CityObjects[ objectId ];\n\n\t// \tif ( ! ( cityObject.geometry &&\n\t// \t  cityObject.geometry.length > 0 ) ) {\n\n\t// \t  return;\n\n\t// \t}\n\n\t// \tconst geom = new Geometry();\n\t// \tlet vertices = [];\n\n\t// \tfor ( let geom_i = 0; geom_i < cityObject.geometry.length; geom_i ++ ) {\n\n\t// \t  //each geometrytype must be handled different\n\t// \t  const geomType = cityObject.geometry[ geom_i ].type;\n\n\t// \t  if ( geomType == \"Solid\" ) {\n\n\t// \t\t\tconst shells = cityObject.geometry[ geom_i ].boundaries;\n\n\t// \t\t\tfor ( let i = 0; i < shells.length; i ++ ) {\n\n\t// \t\t\t\tthis.parseShell( geom, shells[ i ], vertices, json );\n\n\t// \t\t\t}\n\n\t// \t\t} else if ( geomType == \"MultiSurface\" || geomType == \"CompositeSurface\" ) {\n\n\t// \t\t\tconst surfaces = cityObject.geometry[ geom_i ].boundaries;\n\n\t// \t\t\tthis.parseShell( geom, surfaces, vertices, json );\n\n\t// \t\t} else if ( geomType == \"MultiSolid\" || geomType == \"CompositeSolid\" ) {\n\n\t// \t\t\tconst solids = cityObject.geometry[ geom_i ].boundaries;\n\n\t// \t\t\tfor ( let i = 0; i < solids.length; i ++ ) {\n\n\t// \t\t\t\tfor ( let j = 0; j < solids[ i ].length; j ++ ) {\n\n\t// \t\t\t\t\tthis.parseShell( geom, solids[ i ][ j ], vertices, json );\n\n\t// \t\t\t\t}\n\n\t// \t\t\t}\n\n\t// \t\t}\n\n\t// \t}\n\n\t// \tif ( this.matrix !== null ) {\n\n\t// \t\tgeom.applyMatrix4( this.matrix );\n\n\t// \t}\n\n\t// \tgeom.computeFaceNormals();\n\n\t// \treturn geom;\n\n\t// }\n\n\t// parseShell( geom, boundaries, vertices, json ) {\n\n\t// \t// Contains the boundary but with the right verticeId\n\t// \tfor ( let i = 0; i < boundaries.length; i ++ ) {\n\n\t// \t\tlet boundary = [];\n\t// \t\tlet holes = [];\n\n\t// \t\tfor ( let j = 0; j < boundaries[ i ].length; j ++ ) {\n\n\t// \t\t\tif ( boundary.length > 0 ) {\n\n\t// \t\t\t\tholes.push( boundary.length );\n\n\t// \t\t\t}\n\n\t// \t\t\tconst new_boundary = this.extractLocalIndices( geom, boundaries[ i ][ j ], vertices, json );\n\t// \t\t\tboundary.push( ...new_boundary );\n\n\t// \t\t}\n\n\t// \t\tif ( boundary.length == 3 ) {\n\n\t// \t\t\tgeom.faces.push( new Face3( boundary[ 0 ], boundary[ 1 ], boundary[ 2 ] ) );\n\n\t// \t\t} else if ( boundary.length > 3 ) {\n\n\t// \t\t\t//create list of points\n\t// \t\t\tlet pList = [];\n\t// \t\t\tfor ( let k = 0; k < boundary.length; k ++ ) {\n\n\t// \t\t\t\tpList.push( {\n\t// \t\t\t\t\tx: json.vertices[ vertices[ boundary[ k ] ] ][ 0 ],\n\t// \t\t\t\t\ty: json.vertices[ vertices[ boundary[ k ] ] ][ 1 ],\n\t// \t\t\t\t\tz: json.vertices[ vertices[ boundary[ k ] ] ][ 2 ]\n\t// \t\t\t\t} );\n\n\t// \t\t\t}\n\n\t// \t\t\t//get normal of these points\n\t// \t\t\tconst normal = this.get_normal_newell( pList );\n\n\t// \t\t\t//convert to 2d (for triangulation)\n\t// \t\t\tlet pv = [];\n\t// \t\t\tfor ( let k = 0; k < pList.length; k ++ ) {\n\n\t// \t\t\t\tconst re = this.to_2d( pList[ k ], normal );\n\t// \t\t\t\tpv.push( re.x );\n\t// \t\t\t\tpv.push( re.y );\n\n\t// \t\t\t}\n\n\t// \t\t\t//triangulate\n\t// \t\t\tconst tr = earcut( pv, holes, 2 );\n\n\t// \t\t\t//create faces based on triangulation\n\t// \t\t\tfor ( let k = 0; k < tr.length; k += 3 ) {\n\n\t// \t\t\t\tgeom.faces.push(\n\t// \t\t\t\t\tnew Face3(\n\t// \t\t\t\t\t\tboundary[ tr[ k ] ],\n\t// \t\t\t\t\t\tboundary[ tr[ k + 1 ] ],\n\t// \t\t\t\t\t\tboundary[ tr[ k + 2 ] ]\n\t// \t\t\t\t\t)\n\t// \t\t\t\t);\n\n\t// \t\t\t}\n\n\t// \t\t}\n\n\t// \t}\n\n\t// }\n\n\t// extractLocalIndices( geom, boundary, indices, json ) {\n\n\t// \tlet new_boundary = [];\n\n\t// \tfor ( let j = 0; j < boundary.length; j ++ ) {\n\n\t// \t\t//the original index from the json file\n\t// \t\tconst index = boundary[ j ];\n\n\t// \t\t//if this index is already there\n\t// \t\tif ( indices.includes( index ) ) {\n\n\t// \t\t\tconst vertPos = indices.indexOf( index );\n\t// \t\t\tnew_boundary.push( vertPos );\n\n\t// \t\t} else {\n\n\t// \t\t\t// Add vertex to geometry\n\t// \t\t\tconst point = new Vector3(\n\t// \t\t\t\tjson.vertices[ index ][ 0 ],\n\t// \t\t\t\tjson.vertices[ index ][ 1 ],\n\t// \t\t\t\tjson.vertices[ index ][ 2 ]\n\t// \t\t\t);\n\t// \t\t\tgeom.vertices.push( point );\n\n\t// \t\t\tnew_boundary.push( indices.length );\n\t// \t\t\tindices.push( index );\n\n\t// \t\t}\n\n\t// \t}\n\n\t// \treturn new_boundary;\n\n\t// }\n\n\t// get_normal_newell( indices ) {\n\n\t// \t// find normal with Newell's method\n\t// \tlet n = [ 0.0, 0.0, 0.0 ];\n\n\t// \tfor ( let i = 0; i < indices.length; i ++ ) {\n\n\t// \t  let nex = i + 1;\n\n\t// \t  if ( nex == indices.length ) {\n\n\t// \t\t\tnex = 0;\n\n\t// \t\t}\n\n\t// \t  n[ 0 ] = n[ 0 ] + ( ( indices[ i ].y - indices[ nex ].y ) * ( indices[ i ].z + indices[ nex ].z ) );\n\t// \t  n[ 1 ] = n[ 1 ] + ( ( indices[ i ].z - indices[ nex ].z ) * ( indices[ i ].x + indices[ nex ].x ) );\n\t// \t  n[ 2 ] = n[ 2 ] + ( ( indices[ i ].x - indices[ nex ].x ) * ( indices[ i ].y + indices[ nex ].y ) );\n\n\t// \t}\n\n\t// \tconst b = new Vector3( n[ 0 ], n[ 1 ], n[ 2 ] );\n\t// \treturn ( b.normalize() );\n\n\t// }\n\n\t// to_2d( p, n ) {\n\n\t// \tp = new Vector3( p.x, p.y, p.z );\n\t// \tconst x3 = new Vector3( 1.1, 1.1, 1.1 );\n\t// \tif ( x3.distanceTo( n ) < 0.01 ) {\n\n\t// \t  x3.add( new Vector3( 1.0, 2.0, 3.0 ) );\n\n\t// \t}\n\n\t// \tlet tmp = x3.dot( n );\n\t// \tlet tmp2 = n.clone();\n\t// \ttmp2.multiplyScalar( tmp );\n\t// \tx3.sub( tmp2 );\n\t// \tx3.normalize();\n\n\t// \tlet y3 = n.clone();\n\t// \ty3.cross( x3 );\n\n\t// \tlet x = p.dot( x3 );\n\t// \tlet y = p.dot( y3 );\n\n\t// \tconst re = { x: x, y: y };\n\n\t// \treturn re;\n\n\t// }\n\n}\n","import { Matrix4, ShaderLib } from 'three';\nimport { defaultObjectColors, defaultSemanticsColors } from '../defaults/colors.js';\nimport { POINTS, LINES, TRIANGLES } from './geometry/GeometryData.js';\nimport 'three/examples/jsm/lines/LineMaterial.js';\nimport { CityObjectsMaterial } from '../materials/CityObjectsMaterial.js';\nimport { CityObjectsMesh } from '../objects/CityObjectsMesh.js';\nimport { CityObjectsLines } from '../objects/CityObjectsLines.js';\nimport { CityObjectsPoints } from '../objects/CityObjectsPoints.js';\nimport { CityObjectsLineMaterial } from '../materials/CityObjectsLineMaterial.js';\nimport { CityObjectsPointsMaterial } from '../materials/CityObjectsPointsMaterial.js';\nimport { TriangleParser } from './geometry/TriangleParser.js';\nimport { LineParser } from './geometry/LineParser.js';\nimport { PointParser } from './geometry/PointParser.js';\nimport { CityObjectsInstancedMesh } from '../objects/CityObjectsInstancedMesh.js';\n\nexport class CityJSONWorkerParser {\n\n\tconstructor() {\n\n\t\tthis.matrix = null;\n\t\tthis.onChunkLoad = null;\n\t\tthis.onComplete = null;\n\t\tthis.chunkSize = 2000;\n\t\tthis.loading = false;\n\n\t\tthis.objectColors = defaultObjectColors;\n\t\tthis.surfaceColors = defaultSemanticsColors;\n\n\t\tthis.lods = [];\n\n\t\tthis.resetMaterial();\n\n\t}\n\n\tresetMaterial() {\n\n\t\tthis.meshMaterial = new CityObjectsMaterial( ShaderLib.lambert, {\n\t\t\tobjectColors: this.objectColors,\n\t\t\tsurfaceColors: this.surfaceColors\n\t\t} );\n\n\t\tthis.lineMaterial = new CityObjectsLineMaterial( {\n\n\t\t\tcolor: 0xffffff,\n\t\t\tlinewidth: 0.001,\n\t\t\tvertexColors: false,\n\t\t\tdashed: false,\n\t\t\tobjectColors: this.objectColors,\n\t\t\tsurfaceColors: this.surfaceColors\n\n\t\t} );\n\n\t\tthis.pointsMaterial = new CityObjectsPointsMaterial( {\n\t\t\tsize: 10,\n\t\t\tobjectColors: this.objectColors,\n\t\t\tsurfaceColors: this.surfaceColors\n\t\t} );\n\n\t}\n\n\tsetMaterialsColors( objectColors, surfaceColors ) {\n\n\t\tthis.meshMaterial.objectColors = objectColors;\n\t\tthis.meshMaterial.surfaceColors = surfaceColors;\n\n\t\tthis.lineMaterial.objectColors = objectColors;\n\t\tthis.lineMaterial.surfaceColors = surfaceColors;\n\n\t\tthis.pointsMaterial.objectColors = objectColors;\n\t\tthis.pointsMaterial.surfaceColors = surfaceColors;\n\n\t}\n\n\tparse( data, scene ) {\n\n\t\tthis.loading = true;\n\n\t\t// Sets the web worker that will parse all normal (ie non-instanced)\n\t\t// geometries\n\t\tconst worker = new Worker( new URL( \"./helpers/ParserWorker.js\", import.meta.url ), { type: 'module' } );\n\t\tconst m = this.matrix;\n\t\tconst onChunkLoad = this.onChunkLoad;\n\t\tconst onComplete = this.onComplete;\n\t\tconst context = this;\n\t\tconst citymodel = data;\n\n\t\tworker.onmessage = function ( e ) {\n\n\t\t\tif ( e.data.type === \"chunkLoaded\" ) {\n\n\t\t\t\tconst vertices = e.data.v_buffer;\n\t\t\t\tconst geometryData = e.data.geometryData;\n\n\t\t\t\tcontext.setMaterialsColors( e.data.objectColors, e.data.surfaceColors );\n\n\t\t\t\tcontext.lods = e.data.lods;\n\t\t\t\tcontext.objectColors = e.data.objectColors;\n\t\t\t\tcontext.surfaceColors = e.data.surfaceColors;\n\n\t\t\t\tif ( e.data.geometryData.geometryType == TRIANGLES ) {\n\n\t\t\t\t\tconst mesh = new CityObjectsMesh( citymodel, vertices, geometryData, m, context.meshMaterial );\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t}\n\n\t\t\t\tif ( e.data.geometryData.geometryType == LINES ) {\n\n\t\t\t\t\tconst lines = new CityObjectsLines( citymodel, vertices, geometryData, m, context.lineMaterial );\n\t\t\t\t\tscene.add( lines );\n\n\t\t\t\t}\n\n\t\t\t\tif ( e.data.geometryData.geometryType == POINTS ) {\n\n\n\t\t\t\t\tconst points = new CityObjectsPoints( citymodel, vertices, geometryData, m, context.pointsMaterial );\n\t\t\t\t\tscene.add( points );\n\n\t\t\t\t}\n\n\t\t\t\tif ( onChunkLoad ) {\n\n\t\t\t\t\tonChunkLoad();\n\n\t\t\t\t}\n\n\t\t\t} else if ( e.data.type === \"done\" ) {\n\n\t\t\t\tcontext.loading = false;\n\n\t\t\t\tif ( data.appearance && data.appearance.materials ) {\n\n\t\t\t\t\tcontext.meshMaterial.materials = data.appearance.materials;\n\n\t\t\t\t}\n\n\t\t\t\tif ( onComplete ) {\n\n\t\t\t\t\tonComplete();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tworker.postMessage( [ data, { chunkSize: this.chunkSize, objectColors: this.objectColors, lods: this.lods } ] );\n\n\t\t// Parse geometry templates\n\t\tif ( data[ 'geometry-templates' ] ) {\n\n\t\t\tconst templatesGeomData = [];\n\n\t\t\tconst vertices = data[ 'geometry-templates' ][ 'vertices-templates' ];\n\n\t\t\tconst geometryParsers = [\n\t\t\t\tnew TriangleParser( data, Object.keys( data.CityObjects ), this.objectColors, vertices ),\n\t\t\t\tnew LineParser( data, Object.keys( data.CityObjects ), this.objectColors, vertices ),\n\t\t\t\tnew PointParser( data, Object.keys( data.CityObjects ), this.objectColors, vertices )\n\t\t\t];\n\n\t\t\tfor ( const template of data[ 'geometry-templates' ].templates ) {\n\n\t\t\t\tfor ( const geometryParser of geometryParsers ) {\n\n\t\t\t\t\tgeometryParser.lods = this.lods;\n\t\t\t\t\tgeometryParser.parseGeometry( template, - 1, - 1 );\n\t\t\t\t\tthis.lods = geometryParser.lods;\n\n\t\t\t\t\tif ( geometryParser.geomData.count() > 0 ) {\n\n\t\t\t\t\t\ttemplatesGeomData.push( geometryParser.geomData );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometryParser.clean();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst instances = [];\n\n\t\t\tfor ( let i = 0; i < templatesGeomData.length; i ++ ) {\n\n\t\t\t\tinstances.push( {\n\t\t\t\t\tmatrices: [],\n\t\t\t\t\tobjectIds: [],\n\t\t\t\t\tobjectType: [],\n\t\t\t\t\tgeometryIds: []\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfor ( const objectId in data.CityObjects ) {\n\n\t\t\t\tconst cityObject = data.CityObjects[ objectId ];\n\n\t\t\t\tif ( cityObject.geometry && cityObject.geometry.length > 0 ) {\n\n\t\t\t\t\tfor ( let i = 0; i < cityObject.geometry.length; i ++ ) {\n\n\t\t\t\t\t\tconst geometry = cityObject.geometry[ i ];\n\n\t\t\t\t\t\tif ( geometry.type == \"GeometryInstance\" ) {\n\n\t\t\t\t\t\t\tconst matrix = new Matrix4();\n\t\t\t\t\t\t\tmatrix.set( ... geometry.transformationMatrix );\n\t\t\t\t\t\t\tmatrix.setPosition( ... data.vertices[ geometry.boundaries[ 0 ] ] );\n\n\t\t\t\t\t\t\tinstances[ geometry.template ].matrices.push( matrix );\n\t\t\t\t\t\t\tinstances[ geometry.template ].objectIds.push( Object.keys( data.CityObjects ).indexOf( objectId ) );\n\t\t\t\t\t\t\tinstances[ geometry.template ].objectType.push( Object.keys( this.objectColors ).indexOf( cityObject.type ) );\n\t\t\t\t\t\t\tinstances[ geometry.template ].geometryIds.push( i );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < templatesGeomData.length; i ++ ) {\n\n\t\t\t\tif ( templatesGeomData[ i ].geometryType == TRIANGLES ) {\n\n\t\t\t\t\tconst mesh = new CityObjectsInstancedMesh( citymodel, templatesGeomData[ i ].getVertices( vertices ), templatesGeomData[ i ], instances[ i ], m, this.meshMaterial );\n\t\t\t\t\tscene.add( mesh );\n\n\n\t\t\t\t} else if ( templatesGeomData[ i ].geometryType == LINES ) {\n\n\t\t\t\t\tfor ( let j = 0; j < instances[ i ].matrices.length; j ++ ) {\n\n\t\t\t\t\t\ttemplatesGeomData[ i ].setObjectId( instances[ i ].objectIds[ j ] );\n\t\t\t\t\t\ttemplatesGeomData[ i ].setObjectType( instances[ i ].objectType[ j ] );\n\t\t\t\t\t\ttemplatesGeomData[ i ].setGeometryIdx( instances[ i ].geometryIds[ j ] );\n\n\t\t\t\t\t\tconst line = new CityObjectsLines( templatesGeomData[ i ].getVertices( vertices ), templatesGeomData[ i ], m, this.lineMaterial );\n\t\t\t\t\t\tline.applyMatrix4( instances[ i ].matrices[ j ] );\n\t\t\t\t\t\tscene.add( line );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( templatesGeomData[ i ].geometryType == POINTS ) {\n\n\t\t\t\t\tfor ( let j = 0; j < instances[ i ].matrices.length; j ++ ) {\n\n\t\t\t\t\t\ttemplatesGeomData[ i ].setObjectId( instances[ i ].objectIds[ j ] );\n\t\t\t\t\t\ttemplatesGeomData[ i ].setObjectType( instances[ i ].objectType[ j ] );\n\t\t\t\t\t\ttemplatesGeomData[ i ].setGeometryIdx( instances[ i ].geometryIds[ j ] );\n\n\t\t\t\t\t\tconst line = new CityObjectsPoints( templatesGeomData[ i ].getVertices( vertices ), templatesGeomData[ i ], m, this.pointsMaterial );\n\t\t\t\t\t\tline.applyMatrix4( instances[ i ].matrices[ j ] );\n\t\t\t\t\t\tscene.add( line );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n","export const defaultObjectColors = {\n\t\"Building\": 0x7497df,\n\t\"BuildingPart\": 0x7497df,\n\t\"BuildingInstallation\": 0x7497df,\n\t\"Bridge\": 0x999999,\n\t\"BridgePart\": 0x999999,\n\t\"BridgeInstallation\": 0x999999,\n\t\"BridgeConstructionElement\": 0x999999,\n\t\"CityObjectGroup\": 0xffffb3,\n\t\"CityFurniture\": 0xcc0000,\n\t\"GenericCityObject\": 0xcc0000,\n\t\"LandUse\": 0xffffb3,\n\t\"PlantCover\": 0x39ac39,\n\t\"Railway\": 0x000000,\n\t\"Road\": 0x999999,\n\t\"SolitaryVegetationObject\": 0x39ac39,\n\t\"TINRelief\": 0xffdb99,\n\t\"TransportSquare\": 0x999999,\n\t\"Tunnel\": 0x999999,\n\t\"TunnelPart\": 0x999999,\n\t\"TunnelInstallation\": 0x999999,\n\t\"WaterBody\": 0x4da6ff\n};\n\nexport const defaultSemanticsColors = {\n\t\"GroundSurface\": 0x999999,\n\t\"WallSurface\": 0xffffff,\n\t\"RoofSurface\": 0xff0000,\n\t\"TrafficArea\": 0x6e6e6e,\n\t\"AuxiliaryTrafficArea\": 0x2c8200,\n\t\"Window\": 0x0059ff,\n\t\"Door\": 0x640000\n};\n","// Geometry types\nexport const POINTS = 0;\nexport const LINES = 1;\nexport const TRIANGLES = 2;\n\nexport class GeometryData {\n\n\tconstructor( geometryType ) {\n\n\t\tthis.geometryType = geometryType;\n\n\t\tthis.vertexIds = [];\n\t\tthis.objectIds = [];\n\t\tthis.objectTypes = [];\n\t\tthis.semanticSurfaces = [];\n\t\tthis.geometryIds = [];\n\t\tthis.boundaryIds = [];\n\t\tthis.lodIds = [];\n\t\tthis.materials = {};\n\t\tthis.textures = {};\n\n\t}\n\n\tappendMaterial( theme, v ) {\n\n\t\tif ( ! ( theme in this.materials ) ) {\n\n\t\t\tthis.materials[ theme ] = [];\n\n\t\t}\n\n\t\tconst themeArray = this.materials[ theme ];\n\n\t\tfor ( let i = themeArray.length; i < this.count() - 1; i ++ ) {\n\n\t\t\tthemeArray.push( - 1 );\n\n\t\t}\n\n\t\tthis.materials[ theme ].push( v );\n\n\t}\n\n\tappendTexture( theme, values ) {\n\n\t\tif ( ! ( theme in this.textures ) ) {\n\n\t\t\tthis.textures[ theme ] = {\n\t\t\t\tindex: [],\n\t\t\t\tuvs: []\n\t\t\t};\n\n\t\t}\n\n\t\tconst themeObject = this.textures[ theme ];\n\n\t\tfor ( let i = themeObject.index.length; i < this.count() - 1; i ++ ) {\n\n\t\t\tthemeObject.index.push( - 1 );\n\t\t\tthemeObject.uvs.push( [ 0, 0 ] );\n\n\t\t}\n\n\t\tthemeObject.index.push( values.index );\n\t\tthemeObject.uvs.push( values.uvs );\n\n\t}\n\n\taddVertex( vertexId, objectId, objectType, surfaceType, geometryIdx, boundaryIdx, lodIdx, material, texture ) {\n\n\t\tthis.vertexIds.push( vertexId );\n\t\tthis.objectIds.push( objectId );\n\t\tthis.objectTypes.push( objectType );\n\t\tthis.semanticSurfaces.push( surfaceType );\n\t\tthis.geometryIds.push( geometryIdx );\n\t\tthis.boundaryIds.push( boundaryIdx );\n\t\tthis.lodIds.push( lodIdx );\n\n\t\tif ( material ) {\n\n\t\t\tconst context = this;\n\n\t\t\tObject.entries( material ).forEach( entry => {\n\n\t\t\t\tconst [ theme, value ] = entry;\n\n\t\t\t\tcontext.appendMaterial( theme, value );\n\n\t\t\t} );\n\n\t\t}\n\n\t\tif ( texture ) {\n\n\t\t\tconst context = this;\n\n\t\t\tObject.entries( texture ).forEach( entry => {\n\n\t\t\t\tconst [ theme, value ] = entry;\n\n\t\t\t\tcontext.appendTexture( theme, value );\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\tcompleteMaterials() {\n\n\t\tfor ( const theme in this.materials ) {\n\n\t\t\tconst themeArray = this.materials[ theme ];\n\n\t\t\tfor ( let i = themeArray.length; i < this.count(); i ++ ) {\n\n\t\t\t\tthemeArray.push( - 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcompleteTextures() {\n\n\t\tfor ( const theme in this.textures ) {\n\n\t\t\tconst themeObject = this.textures[ theme ];\n\n\t\t\tfor ( let i = themeObject.index.length; i < this.count(); i ++ ) {\n\n\t\t\t\tthemeObject.index.push( - 1 );\n\t\t\t\tthemeObject.uvs.push( [ 0, 0 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcount() {\n\n\t\treturn this.vertexIds.length;\n\n\t}\n\n\tgetVertices( vertexList ) {\n\n\t\tlet vertices = [];\n\n\t\tfor ( const vertexIndex of this.vertexIds ) {\n\n\t\t\tconst vertex = vertexList[ vertexIndex ];\n\n\t\t\tvertices.push( ...vertex );\n\n\t\t}\n\n\t\treturn vertices;\n\n\t}\n\n\ttoObject() {\n\n\t\tthis.completeMaterials();\n\t\tthis.completeTextures();\n\n\t\treturn {\n\t\t\tgeometryType: this.geometryType,\n\t\t\tobjectIds: this.objectIds,\n\t\t\tobjectType: this.objectTypes,\n\t\t\tsemanticSurfaces: this.semanticSurfaces,\n\t\t\tgeometryIds: this.geometryIds,\n\t\t\tboundaryIds: this.boundaryIds,\n\t\t\tlodIds: this.lodIds,\n\t\t\tmaterials: this.materials,\n\t\t\ttextures: this.textures\n\t\t};\n\n\t}\n\n\tsetObjectId( objectId ) {\n\n\t\tfor ( let i = 0; i < this.objectIds.length; i ++ ) {\n\n\t\t\tthis.objectIds[ i ] = objectId;\n\n\t\t}\n\n\t}\n\n\n\tsetObjectType( objectType ) {\n\n\t\tfor ( let i = 0; i < this.objectTypes.length; i ++ ) {\n\n\t\t\tthis.objectTypes[ i ] = objectType;\n\n\t\t}\n\n\t}\n\n\tsetGeometryIdx( geometryIdx ) {\n\n\t\tfor ( let i = 0; i < this.geometryIds.length; i ++ ) {\n\n\t\t\tthis.geometryIds[ i ] = geometryIdx;\n\n\t\t}\n\n\t}\n\n\tmerge( otherGeomData ) {\n\n\t\tif ( otherGeomData.geometryType != this.geometryType ) {\n\n\t\t\tconsole.warn( \"Merging different types of geometry data!\" );\n\n\t\t}\n\n\t\tthis.vertexIds.concat( this.otherGeomData.vertexId );\n\t\tthis.objectIds.concat( this.otherGeomData.objectId );\n\t\tthis.objectTypes.concat( this.otherGeomData.objectType );\n\t\tthis.semanticSurfaces.concat( this.otherGeomData.surfaceType );\n\t\tthis.geometryIds.concat( this.otherGeomData.geometryIdx );\n\t\tthis.boundaryIds.concat( this.otherGeomData.boundaryIdx );\n\t\tthis.lodIds.concat( this.otherGeomData.lodIdx );\n\n\t}\n\n}\n","import { ShaderChunk, UniformsLib, UniformsUtils } from \"three\";\nimport { CityObjectsBaseMaterial } from \"./CityObjectsBaseMaterial.js\";\n\nexport class CityObjectsMaterial extends CityObjectsBaseMaterial {\n\n\tconstructor( shader, parameters ) {\n\n\t\tconst newShader = { ...shader };\n\t\tnewShader.uniforms = {\n\t\t\t...UniformsUtils.clone( UniformsLib.cityobject ),\n\t\t\t...UniformsUtils.clone( shader.uniforms ),\n\t\t};\n\t\tnewShader.extensions = {\n\t\t\tderivatives: true,\n\t\t};\n\t\tnewShader.lights = true;\n\t\tnewShader.vertexShader =\n\t\tShaderChunk.cityobjectinclude_vertex +\n\t\tnewShader.vertexShader.replace(\n\t\t\t/#include <fog_vertex>/,\n\t\t\t`\n\t\t\t#include <fog_vertex>\n\t\t\t`\n\t\t\t+ ShaderChunk.cityobjectdiffuse_vertex\n\t\t\t+ ShaderChunk.cityobjectshowlod_vertex\n\t\t);\n\t\tnewShader.fragmentShader =\n\t\t`\n\t\t\tvarying vec3 diffuse_;\n\t\t\tvarying float discard_;\n\n\t\t\t#ifdef TEXTURE_THEME\n\n\t\t\t\tuniform sampler2D cityTexture;\n\n\t\t\t\tflat in int vTexIndex;\n\t\t\t\tvarying vec2 vTexUV;\n\n\t\t\t#endif\n\n\t\t\t#ifdef MATERIAL_THEME\n\n\t\t\t\tvarying vec3 emissive_;\n\t\t\t\n\t\t\t#endif\n\t\t` +\n\t\tnewShader.fragmentShader.replace(\n\t\t\t/vec4 diffuseColor = vec4\\( diffuse, opacity \\);/,\n\t\t\t`\n\t\t\tvec4 diffuseColor = vec4( diffuse_, opacity );\n\n\t\t\t#ifdef TEXTURE_THEME\n\n\t\t\t\tif ( vTexIndex > - 1 ) {\n\n\t\t\t\t\tvec4 tempDiffuseColor = vec4(1.0, 1.0, 1.0, 0.0);\n\n\t\t\t\t\ttempDiffuseColor = texture2D( cityTexture, vTexUV );\n\n\t\t\t\t\tdiffuseColor *= tempDiffuseColor;\n\n\t\t\t\t}\n\n\t\t\t#endif\n\n\t\t\t#ifdef SHOW_LOD\n\n\t\t\t\tif ( discard_ > 0.0 ) {\n\t\t\t\t\tdiscard;\n\t\t\t\t}\n\t\t\t\n\t\t\t#endif\n\t\t\t`\n\t\t).replace(\n\t\t\t/vec3 totalEmissiveRadiance = emissive;/,\n\t\t\t`\n\t\t\t#ifdef MATERIAL_THEME\n\n\t\t\t\tvec3 totalEmissiveRadiance = emissive_;\n\n\t\t\t#else\n\n\t\t\t\tvec3 totalEmissiveRadiance = emissive;\n\n\t\t\t#endif\n\t\t\t`\n\t\t);\n\n\t\tsuper( newShader );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n}\n","import { Color, ShaderChunk, ShaderMaterial, UniformsLib } from \"three\";\n\nUniformsLib.cityobject = {\n\n\tobjectColors: { value: [] },\n\tsurfaceColors: { value: [] },\n\tattributeColors: { value: [] },\n\tcityMaterials: { value: [] },\n\tcityTexture: { type: 't' },\n\tshowLod: { value: - 1 },\n\thighlightedObjId: { value: - 1 },\n\thighlightedGeomId: { value: - 1 },\n\thighlightedBoundId: { value: - 1 },\n\thighlightColor: { value: new Color( 0xFFC107 ).convertSRGBToLinear() }\n\n};\n\nShaderChunk.cityobjectinclude_vertex = `\n        uniform vec3 objectColors[ OBJCOLOR_COUNT ];\n        uniform vec3 highlightColor;\n        uniform float highlightedObjId;\n        \n        attribute float objectid;\n        attribute int type;\n        \n        varying vec3 diffuse_;\n\n        #ifdef SHOW_SEMANTICS\n\n            uniform vec3 surfaceColors[ SEMANTIC_COUNT ];\n\n            attribute int surfacetype;\n\n        #endif\n\n\t\t#ifdef COLOR_ATTRIBUTE\n\n            uniform vec3 attributeColors[ ATTRIBUTE_COUNT ];\n\n            attribute int attributevalue;\n\n        #endif\n\n        #ifdef SELECT_SURFACE\n\n            uniform float highlightedGeomId;\n            uniform float highlightedBoundId;\n\n            attribute float geometryid;\n            attribute float boundaryid;\n\n        #endif\n\n        #ifdef SHOW_LOD\n\n            uniform float showLod;\n\n            attribute float lodid;\n\n            varying float discard_;\n    \n        #endif\n\n\t\t#ifdef MATERIAL_THEME\n\n\t\t\tstruct CityMaterial\n\t\t\t{\n\t\t\t\tvec3 diffuseColor;\n\t\t\t\tvec3 emissiveColor;\n\t\t\t\tvec3 specularColor;\n\t\t\t};\n\n\t\t\tuniform CityMaterial cityMaterials[ MATERIAL_COUNT ];\n\n\t\t\tvarying vec3 emissive_;\n\n\t\t\tattribute int MATERIAL_THEME;\n\n\t\t#endif\n\n\t\t#ifdef TEXTURE_THEME\n\n\t\t\tattribute int TEXTURE_THEME;\n\t\t\tattribute vec2 TEXTURE_THEME_UV;\n\n\t\t\tflat out int vTexIndex;\n\t\t\tvarying vec2 vTexUV;\n\n\t\t#endif\n    `;\n\nShaderChunk.cityobjectdiffuse_vertex = `\n        #ifdef SHOW_SEMANTICS\n\n            diffuse_ = surfacetype > -1 ? surfaceColors[surfacetype] : objectColors[type];\n\n        #else\n\n            diffuse_ = objectColors[type];\n\n        #endif\n\n\t\t#ifdef COLOR_ATTRIBUTE\n\n            diffuse_ = attributevalue > -1 ? attributeColors[attributevalue] : vec3( 0.0, 0.0, 0.0 );\n\n        #endif\n\n\t\t#ifdef MATERIAL_THEME\n\n\t\t\tif ( MATERIAL_THEME > - 1 ) {\n\n\t\t\t\tdiffuse_ = cityMaterials[ MATERIAL_THEME ].diffuseColor;\n\t\t\t\temissive_ = cityMaterials[ MATERIAL_THEME ].emissiveColor;\n\n\t\t\t}\n\n\t\t#endif\n\n\t\t#ifdef TEXTURE_THEME\n\n\t\t\tvTexIndex = TEXTURE_THEME;\n\t\t\tvTexUV = TEXTURE_THEME_UV;\n\n\t\t\tif ( vTexIndex > - 1 ) {\n\n\t\t\t\tdiffuse_ = vec3( 1.0, 1.0, 1.0 );\n\n\t\t\t}\n\n\t\t#endif\n\n        #ifdef SELECT_SURFACE\n\n            diffuse_ = abs( objectid - highlightedObjId ) < 0.5 && abs( geometryid - highlightedGeomId ) < 0.5 && abs( boundaryid - highlightedBoundId ) < 0.5 ? highlightColor : diffuse_;\n\n        #else\n\n            diffuse_ = abs( objectid - highlightedObjId ) < 0.5 ? highlightColor : diffuse_;\n\n        #endif\n    `;\n\nShaderChunk.cityobjectshowlod_vertex = `\n        #ifdef SHOW_LOD\n\n            if ( abs ( lodid - showLod ) > 0.5 ) {\n                discard_ = 1.0;\n            }\n\n        #endif\n    `;\n\nexport class CityObjectsBaseMaterial extends ShaderMaterial {\n\n\tconstructor( shader ) {\n\n\t\tsuper( shader );\n\n\t\tthis.objectColors = {};\n\t\tthis.surfaceColors = {};\n\t\tthis.attributeColors = {};\n\t\tthis.materials = [];\n\t\tthis.showSemantics = true;\n\n\t\tthis.textures = [];\n\n\t\tthis.instancing = false;\n\n\t\tthis.isCityObjectsMaterial = true;\n\n\t\tthis.defines.OBJCOLOR_COUNT = 0;\n\t\tthis.defines.SEMANTIC_COUNT = 0;\n\t\tthis.defines.ATTRIBUTE_COUNT = 0;\n\t\tthis.defines.MATERIAL_COUNT = 0;\n\n\t}\n\n\tcreateColorsArray( colors ) {\n\n\t\tconst data = [];\n\t\tfor ( const type in colors ) {\n\n\t\t\tconst color = new Color( colors[ type ] );\n\n\t\t\tdata.push( color.convertSRGBToLinear() );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tset attributeColors( colors ) {\n\n\t\tthis.attributeColorsLookup = colors;\n\n\t\tthis.uniforms.attributeColors.value = this.createColorsArray( colors );\n\t\tthis.defines.ATTRIBUTE_COUNT = Object.keys( colors ).length;\n\n\t}\n\n\tget attributeColors() {\n\n\t\treturn this.attributeColorsLookup;\n\n\t}\n\n\tget conditionalFormatting() {\n\n\t\treturn Boolean( 'COLOR_ATTRIBUTE' in this.defines );\n\n\t}\n\n\tset conditionalFormatting( value ) {\n\n\t\tif ( Boolean( value ) !== Boolean( 'COLOR_ATTRIBUTE' in this.defines ) ) {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.defines.COLOR_ATTRIBUTE = '';\n\n\t\t} else {\n\n\t\t\tdelete this.defines.COLOR_ATTRIBUTE;\n\n\t\t}\n\n\t}\n\n\tset objectColors( colors ) {\n\n\t\tthis.objectColorsLookup = colors;\n\n\t\t// Maybe here we check if the key order has changed\n\t\tthis.uniforms.objectColors.value = this.createColorsArray( colors );\n\t\tthis.defines.OBJCOLOR_COUNT = Object.keys( colors ).length;\n\n\t}\n\n\tget objectColors() {\n\n\t\treturn this.objectColorsLookup;\n\n\t}\n\n\tset surfaceColors( colors ) {\n\n\t\tthis.surfaceColorsLookup = colors;\n\n\t\t// Maybe here we check if the key order has changed\n\t\tthis.uniforms.surfaceColors.value = this.createColorsArray( colors );\n\t\tthis.defines.SEMANTIC_COUNT = Object.keys( colors ).length;\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tget surfaceColors() {\n\n\t\treturn this.surfaceColorsLookup;\n\n\t}\n\n\tget showSemantics() {\n\n\t\treturn Boolean( 'SHOW_SEMANTICS' in this.defines );\n\n\t}\n\n\tset showSemantics( value ) {\n\n\t\tif ( Boolean( value ) !== Boolean( 'SHOW_SEMANTICS' in this.defines ) ) {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.defines.SHOW_SEMANTICS = '';\n\n\t\t} else {\n\n\t\t\tdelete this.defines.SHOW_SEMANTICS;\n\n\t\t}\n\n\t}\n\n\tget selectSurface() {\n\n\t\treturn Boolean( 'SELECT_SURFACE' in this.defines );\n\n\t}\n\n\tset selectSurface( value ) {\n\n\t\tif ( Boolean( value ) !== Boolean( 'SELECT_SURFACE' in this.defines ) ) {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.defines.SELECT_SURFACE = '';\n\n\t\t} else {\n\n\t\t\tdelete this.defines.SELECT_SURFACE;\n\n\t\t}\n\n\t}\n\n\tget showLod() {\n\n\t\treturn this.uniforms.showLod.value;\n\n\t}\n\n\tset showLod( value ) {\n\n\t\tif ( Boolean( value > - 1 ) !== Boolean( 'SHOW_LOD' in this.defines ) ) {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( value > - 1 ) {\n\n\t\t\tthis.defines.SHOW_LOD = '';\n\n\t\t} else {\n\n\t\t\tdelete this.defines.SHOW_LOD;\n\n\t\t}\n\n\t\tthis.uniforms.showLod.value = value;\n\n\t}\n\n\tset materialTheme( value ) {\n\n\t\tconst themeName = value.replace( /[^a-z0-9]/gi, '' );\n\n\t\tif ( themeName !== this.defines.MATERIAL_THEME ) {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( value === \"undefined\" || value === undefined || value == null ) {\n\n\t\t\tdelete this.defines.MATERIAL_THEME;\n\n\t\t} else {\n\n\t\t\tthis.defines.MATERIAL_THEME = `mat${themeName}`;\n\n\t\t}\n\n\t}\n\n\tset textureTheme( value ) {\n\n\t\tconst themeName = value.replace( /[^a-z0-9]/gi, '' );\n\n\t\tif ( themeName !== this.defines.TEXTURE_THEME ) {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( value === \"undefined\" || value === undefined || value == null ) {\n\n\t\t\tdelete this.defines.TEXTURE_THEME;\n\t\t\tdelete this.defines.TEXTURE_THEME_UV;\n\n\t\t} else {\n\n\t\t\tthis.defines.TEXTURE_THEME = `tex${themeName}`;\n\t\t\tthis.defines.TEXTURE_THEME_UV = `tex${themeName}uv`;\n\n\t\t}\n\n\t}\n\n\tset materials( materials ) {\n\n\t\tconst data = [];\n\t\tfor ( let i = 0; i < materials.length; i ++ ) {\n\n\t\t\tconst mat = Object.assign( {\n\t\t\t\tdiffuseColor: [ 1, 1, 1 ],\n\t\t\t\temissiveColor: [ 0, 0, 0 ],\n\t\t\t\tspecularColor: [ 1, 1, 1 ],\n\t\t\t}, materials[ i ] );\n\n\t\t\tmat.diffuseColor = new Color( ...mat.diffuseColor ).convertLinearToSRGB();\n\t\t\tmat.emissiveColor = new Color( ...mat.emissiveColor ).convertLinearToSRGB();\n\t\t\tmat.specularColor = new Color( ...mat.specularColor ).convertLinearToSRGB();\n\n\t\t\tdata.push( mat );\n\n\t\t}\n\n\t\tthis.defines.MATERIAL_COUNT = data.length;\n\n\t\tthis.uniforms.cityMaterials.value = data;\n\n\t}\n\n\tget highlightColor() {\n\n\t\treturn this.uniforms.highlightColor;\n\n\t}\n\n\tset highlightColor( color ) {\n\n\t\tif ( typeof color === 'string' || color instanceof String ) {\n\n\t\t\tthis.uniforms.highlightColor.value.setHex( color.replace( '#', '0x' ) );\n\n\t\t} else if ( color instanceof Number ) {\n\n\t\t\tthis.uniforms.highlightColor.setHex( color );\n\n\t\t} else if ( color instanceof Color ) {\n\n\t\t\tthis.uniforms.highlightColor = color;\n\n\t\t}\n\n\t}\n\n\tget highlightedObject() {\n\n\t\treturn {\n\n\t\t\tobjectIndex: this.uniforms.highlightedObjId.value,\n\t\t\tgeometryIndex: this.uniforms.highlightedGeomId.value,\n\t\t\tboundaryIndex: this.uniforms.highlightedBoundId.value\n\n\t\t};\n\n\t}\n\n\t/**\n\t * Expects an object with three properties: `objectIndex`, `geometryIndex`,\n\t * and `boundaryIndex`.\n\t */\n\tset highlightedObject( objectInfo ) {\n\n\t\tif ( objectInfo ) {\n\n\t\t\tthis.uniforms.highlightedObjId.value = objectInfo.objectIndex === undefined ? - 1 : objectInfo.objectIndex;\n\t\t\tthis.uniforms.highlightedGeomId.value = objectInfo.geometryIndex === undefined ? - 1 : objectInfo.geometryIndex;\n\t\t\tthis.uniforms.highlightedBoundId.value = objectInfo.boundaryIndex === undefined ? - 1 : objectInfo.boundaryIndex;\n\n\t\t} else {\n\n\t\t\tthis.uniforms.highlightedObjId.value = - 1;\n\t\t\tthis.uniforms.highlightedGeomId.value = - 1;\n\t\t\tthis.uniforms.highlightedBoundId.value = - 1;\n\n\t\t}\n\n\t}\n\n}\n","import { BufferAttribute,\n\t\t BufferGeometry,\n\t\t Int32BufferAttribute,\n\t\t Mesh } from 'three';\n\nexport class CityObjectsMesh extends Mesh {\n\n\tconstructor( citymodel, vertices, geometryData, matrix, material ) {\n\n\t\tconst geom = new BufferGeometry();\n\n\t\tconst vertexArray = new Float32Array( vertices );\n\t\tgeom.setAttribute( 'position', new BufferAttribute( vertexArray, 3 ) );\n\t\tconst idsArray = new Uint16Array( geometryData.objectIds );\n\t\tgeom.setAttribute( 'objectid', new BufferAttribute( idsArray, 1 ) );\n\t\tconst typeArray = new Uint8Array( geometryData.objectType );\n\t\tgeom.setAttribute( 'type', new Int32BufferAttribute( typeArray, 1 ) );\n\t\tconst surfaceTypeArray = new Int8Array( geometryData.semanticSurfaces );\n\t\tgeom.setAttribute( 'surfacetype', new Int32BufferAttribute( surfaceTypeArray, 1 ) );\n\t\tconst geomIdsArray = new Float32Array( geometryData.geometryIds );\n\t\tgeom.setAttribute( 'geometryid', new BufferAttribute( geomIdsArray, 1 ) );\n\t\tconst lodIdsArray = new Int8Array( geometryData.lodIds );\n\t\tgeom.setAttribute( 'lodid', new BufferAttribute( lodIdsArray, 1 ) );\n\t\tconst boundaryIdsArray = new Float32Array( geometryData.boundaryIds );\n\t\tgeom.setAttribute( 'boundaryid', new BufferAttribute( boundaryIdsArray, 1 ) );\n\n\t\tfor ( const material in geometryData.materials ) {\n\n\t\t\tconst themeName = material.replace( /[^a-z0-9]/gi, '' );\n\n\t\t\tconst materialArray = new Uint8Array( geometryData.materials[ material ] );\n\t\t\tgeom.setAttribute( `mat${themeName}`, new Int32BufferAttribute( materialArray, 1 ) );\n\n\t\t}\n\n\t\tfor ( const texture in geometryData.textures ) {\n\n\t\t\tconst themeName = texture.replace( /[^a-z0-9]/gi, '' );\n\n\t\t\tconst textureArray = new Int16Array( geometryData.textures[ texture ].index );\n\t\t\tgeom.setAttribute( `tex${themeName}`, new Int32BufferAttribute( textureArray, 1 ) );\n\n\t\t\tconst textureUVs = new Float32Array( geometryData.textures[ texture ].uvs.flat( 1 ) );\n\t\t\tgeom.setAttribute( `tex${themeName}uv`, new BufferAttribute( textureUVs, 2 ) );\n\n\t\t}\n\n\t\tgeom.attributes.position.needsUpdate = true;\n\n\t\tif ( matrix ) {\n\n\t\t\tgeom.applyMatrix4( matrix );\n\n\t\t}\n\n\t\tgeom.computeVertexNormals();\n\n\t\tsuper( geom, material );\n\n\t\tthis.citymodel = citymodel;\n\n\t\tthis.isCityObject = true;\n\t\tthis.isCityObjectMesh = true;\n\n\t\tthis.supportsConditionalFormatting = true;\n\t\tthis.supportsMaterials = true;\n\n\t}\n\n\tsetArrayAsAttribute( array ) {\n\n\t\tthis.geometry.setAttribute( 'attributevalue', new Int32BufferAttribute( new Int32Array( array ), 1 ) );\n\n\t}\n\n\taddAttributeByProperty( attributeEvaluator ) {\n\n\t\tconst allValues = attributeEvaluator.getAllValues();\n\t\tconst uniqueValues = attributeEvaluator.getUniqueValues();\n\n\t\tif ( uniqueValues.length < 110 ) {\n\n\t\t\tconst objectLookup = [];\n\t\t\tfor ( const value of allValues ) {\n\n\t\t\t\tobjectLookup.push( uniqueValues.indexOf( value ) );\n\n\t\t\t}\n\n\t\t\tconst objectIds = this.geometry.attributes.objectid.array;\n\n\t\t\tconst finalArray = objectIds.map( i => {\n\n\t\t\t\treturn objectLookup[ i ];\n\n\t\t\t} );\n\n\t\t\tif ( finalArray.length !== objectIds.length ) {\n\n\t\t\t\tconsole.warn( \"Wrong size of attributes array.\" );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.setArrayAsAttribute( finalArray );\n\n\t\t}\n\n\t}\n\n\tgetIntersectionVertex( intersection ) {\n\n\t\treturn intersection.face.a;\n\n\t}\n\n\tresolveIntersectionInfo( intersection ) {\n\n\t\tconst intersectionInfo = {};\n\n\t\tconst vertexIdx = this.getIntersectionVertex( intersection );\n\n\t\tconst idx = this.geometry.getAttribute( 'objectid' ).getX( vertexIdx );\n\n\t\tintersectionInfo.vertexIndex = vertexIdx;\n\t\tintersectionInfo.objectIndex = idx;\n\t\tintersectionInfo.objectId = Object.keys( this.citymodel.CityObjects )[ idx ];\n\t\tintersectionInfo.geometryIndex = this.geometry.getAttribute( 'geometryid' ).getX( vertexIdx );\n\t\tintersectionInfo.boundaryIndex = this.geometry.getAttribute( 'boundaryid' ).getX( vertexIdx );\n\n\t\tintersectionInfo.objectTypeIndex = this.geometry.getAttribute( 'type' ).getX( vertexIdx );\n\t\tintersectionInfo.surfaceTypeIndex = this.geometry.getAttribute( 'surfacetype' ).getX( vertexIdx );\n\t\tintersectionInfo.lodIndex = this.geometry.getAttribute( 'lodid' ).getX( vertexIdx );\n\n\t\treturn intersectionInfo;\n\n\t}\n\n\tsetTextureTheme( theme, textureManager ) {\n\n\t\tif ( theme === \"undefined\" ) {\n\n\t\t\tthis.unsetTextures();\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst themeName = theme.replace( /[^a-z0-9]/gi, '' );\n\n\t\tconst attributeName = `tex${themeName}`;\n\n\t\tif ( attributeName in this.geometry.attributes ) {\n\n\t\t\tconst textureIds = this.geometry.attributes[ attributeName ].array;\n\n\t\t\t// Create a lookup of textures\n\t\t\tconst { values, indices } = textureIds.reduce( ( p, c, i ) => {\n\n\t\t\t\tif ( p.last !== c ) {\n\n\t\t\t\t\tp.values.push( c );\n\t\t\t\t\tp.indices.push( i );\n\t\t\t\t\tp.last = c;\n\n\t\t  \t\t}\n\n\t\t  \t\treturn p;\n\n\t\t\t}, { last: - 1, values: [], indices: [] } );\n\n\t\t\tconst baseMaterial = Array.isArray( this.material ) ? this.material[ this.material.length - 1 ] : this.material;\n\n\t\t\tconst materials = textureManager.getMaterials( baseMaterial );\n\n\t\t\tfor ( const mat of materials ) {\n\n\t\t\t\tif ( mat !== baseMaterial ) {\n\n\t\t\t\t\tmat.textureTheme = theme;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// TODO: We need to add the last element here\n\t\t\tfor ( let i = 0; i < indices.length - 1; i ++ ) {\n\n\t\t\t\tthis.geometry.addGroup( indices[ i ], indices[ i + 1 ] - indices[ i ], values[ i ] > - 1 ? values[ i ] : materials.length - 1 );\n\n\t\t\t}\n\n\t\t\tconst i = indices.length - 1;\n\n\t\t\tthis.geometry.addGroup( indices[ i ], this.geometry.attributes.type.array.length - indices[ i ], values[ i ] > - 1 ? values[ i ] : materials.length - 1 );\n\n\t\t\tthis.material = materials;\n\n\t\t}\n\n\t}\n\n\tunsetTextures() {\n\n\t\tif ( Array.isArray( this.material ) ) {\n\n\t\t\tthis.material = this.material[ this.material.length - 1 ];\n\n\t\t}\n\n\t\tthis.material.textureTheme = \"undefined\";\n\n\t}\n\n}\n","import { InstancedBufferAttribute } from 'three';\nimport { LineSegments2 } from 'three/examples/jsm/lines/LineSegments2.js';\nimport { LineSegmentsGeometry } from 'three/examples/jsm/lines/LineSegmentsGeometry.js';\n\nfunction removeDuplicates( array ) {\n\n\tlet newArray = [ array.length / 2 ];\n\n\tfor ( let i = 0; i < array.length; i += 2 ) {\n\n\t\tnewArray[ i / 2 ] = array[ i ];\n\n\t}\n\n\treturn newArray;\n\n}\n\nexport class CityObjectsLines extends LineSegments2 {\n\n\tconstructor( citymodel, vertices, geometryData, matrix, material ) {\n\n\t\tconst geom = new LineSegmentsGeometry();\n\n\t\tgeom.setPositions( new Float32Array( vertices ) );\n\n\t\tconst idsArray = new Float32Array( removeDuplicates( geometryData.objectIds ) );\n\t\tgeom.setAttribute( 'objectid', new InstancedBufferAttribute( idsArray, 1 ) );\n\n\t\tconst typeArray = new Int32Array( removeDuplicates( geometryData.objectType ) );\n\t\tgeom.setAttribute( 'type', new InstancedBufferAttribute( typeArray, 1 ) );\n\t\tconst surfaceTypeArray = new Int32Array( removeDuplicates( geometryData.semanticSurfaces ) );\n\t\tgeom.setAttribute( 'surfacetype', new InstancedBufferAttribute( surfaceTypeArray, 1 ) );\n\t\tconst geomIdsArray = new Float32Array( removeDuplicates( geometryData.geometryIds ) );\n\t\tgeom.setAttribute( 'geometryid', new InstancedBufferAttribute( geomIdsArray, 1 ) );\n\t\tconst lodIdsArray = new Uint8Array( removeDuplicates( geometryData.lodIds ) );\n\t\tgeom.setAttribute( 'lodid', new InstancedBufferAttribute( lodIdsArray, 1 ) );\n\t\tconst boundaryIdsArray = new Float32Array( removeDuplicates( geometryData.boundaryIds ) );\n\t\tgeom.setAttribute( 'boundaryid', new InstancedBufferAttribute( boundaryIdsArray, 1 ) );\n\n\t\t// geom.attributes.position.needsUpdate = true;\n\n\t\tif ( matrix ) {\n\n\t\t\tgeom.applyMatrix4( matrix );\n\n\t\t}\n\n\t\tsuper( geom, material );\n\n\t\tthis.citymodel = citymodel;\n\n\t\tthis.isCityObject = true;\n\t\tthis.isCityObjectLine = true;\n\n\t}\n\n\tgetIntersectionVertex( intersection ) {\n\n\t\treturn intersection.faceIndex;\n\n\t}\n\n\tresolveIntersectionInfo( intersection ) {\n\n\t\tconst intersectionInfo = {};\n\n\t\tconst vertexIdx = this.getIntersectionVertex( intersection );\n\n\t\tconst idx = this.geometry.getAttribute( 'objectid' ).getX( vertexIdx );\n\n\t\tintersectionInfo.vertexIndex = vertexIdx;\n\t\tintersectionInfo.objectIndex = idx;\n\n\t\tintersectionInfo.objectId = Object.keys( this.citymodel.CityObjects )[ idx ];\n\t\tintersectionInfo.geometryIndex = this.geometry.getAttribute( 'geometryid' ).getX( vertexIdx );\n\t\tintersectionInfo.boundaryIndex = this.geometry.getAttribute( 'boundaryid' ).getX( vertexIdx );\n\n\t\tintersectionInfo.objectTypeIndex = this.geometry.getAttribute( 'type' ).getX( vertexIdx );\n\t\tintersectionInfo.surfaceTypeIndex = this.geometry.getAttribute( 'surfacetype' ).getX( vertexIdx );\n\t\tintersectionInfo.lodIndex = this.geometry.getAttribute( 'lodid' ).getX( vertexIdx );\n\n\t\treturn intersectionInfo;\n\n\t}\n\n}\n","import { BufferAttribute,\n\t\t BufferGeometry,\n\t\t Int32BufferAttribute,\n\t\t Points } from 'three';\n\nexport class CityObjectsPoints extends Points {\n\n\tconstructor( citymodel, vertices, geometryData, matrix, material ) {\n\n\t\tconst geom = new BufferGeometry();\n\n\t\tconst vertexArray = new Float32Array( vertices );\n\t\tgeom.setAttribute( 'position', new BufferAttribute( vertexArray, 3 ) );\n\t\tconst idsArray = new Uint16Array( geometryData.objectIds );\n\t\tgeom.setAttribute( 'objectid', new BufferAttribute( idsArray, 1 ) );\n\t\tconst typeArray = new Uint8Array( geometryData.objectType );\n\t\tgeom.setAttribute( 'type', new Int32BufferAttribute( typeArray, 1 ) );\n\t\tconst surfaceTypeArray = new Int8Array( geometryData.semanticSurfaces );\n\t\tgeom.setAttribute( 'surfacetype', new Int32BufferAttribute( surfaceTypeArray, 1 ) );\n\t\tconst geomIdsArray = new Float32Array( geometryData.geometryIds );\n\t\tgeom.setAttribute( 'geometryid', new BufferAttribute( geomIdsArray, 1 ) );\n\t\tconst lodIdsArray = new Int8Array( geometryData.lodIds );\n\t\tgeom.setAttribute( 'lodid', new BufferAttribute( lodIdsArray, 1 ) );\n\t\tconst boundaryIdsArray = new Float32Array( geometryData.boundaryIds );\n\t\tgeom.setAttribute( 'boundaryid', new BufferAttribute( boundaryIdsArray, 1 ) );\n\n\t\tgeom.attributes.position.needsUpdate = true;\n\n\t\tif ( matrix ) {\n\n\t\t\tgeom.applyMatrix4( matrix );\n\n\t\t}\n\n\t\tgeom.computeVertexNormals();\n\n\t\tsuper( geom, material );\n\n\t\tthis.citymodel = citymodel;\n\n\t\tthis.isCityObject = true;\n\t\tthis.isCityObjectPoints = true;\n\n\t}\n\n\tgetIntersectionVertex( intersection ) {\n\n\t\treturn intersection.index;\n\n\t}\n\n\tresolveIntersectionInfo( intersection ) {\n\n\t\tconst intersectionInfo = {};\n\n\t\tconst vertexIdx = this.getIntersectionVertex( intersection );\n\n\t\tconst idx = this.geometry.getAttribute( 'objectid' ).getX( vertexIdx );\n\n\t\tintersectionInfo.vertexIndex = vertexIdx;\n\t\tintersectionInfo.objectIndex = idx;\n\n\t\tintersectionInfo.objectId = Object.keys( this.citymodel.CityObjects )[ idx ];\n\t\tintersectionInfo.geometryIndex = this.geometry.getAttribute( 'geometryid' ).getX( vertexIdx );\n\t\tintersectionInfo.boundaryIndex = this.geometry.getAttribute( 'boundaryid' ).getX( vertexIdx );\n\n\t\tintersectionInfo.objectTypeIndex = this.geometry.getAttribute( 'type' ).getX( vertexIdx );\n\t\tintersectionInfo.surfaceTypeIndex = this.geometry.getAttribute( 'surfacetype' ).getX( vertexIdx );\n\t\tintersectionInfo.lodIndex = this.geometry.getAttribute( 'lodid' ).getX( vertexIdx );\n\n\t\treturn intersectionInfo;\n\n\t}\n\n}\n","import { ShaderChunk, ShaderLib,\n\t\t UniformsLib,\n\t\t UniformsUtils } from \"three\";\nimport 'three/examples/jsm/lines/LineMaterial.js';\nimport { CityObjectsBaseMaterial } from \"./CityObjectsBaseMaterial.js\";\n\nexport class CityObjectsLineMaterial extends CityObjectsBaseMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tconst shader = ShaderLib[ 'line' ];\n\n\t\tconst newShader = { ...shader };\n\t\tnewShader.uniforms = {\n\t\t\t...UniformsLib.cityobject,\n\t\t\t...UniformsUtils.clone( shader.uniforms ),\n\t\t};\n\t\tnewShader.extensions = {\n\t\t\tderivatives: true,\n\t\t};\n\t\tnewShader.lights = false;\n\t\tnewShader.vertexShader =\n\t\tShaderChunk.cityobjectinclude_vertex +\n\t\tnewShader.vertexShader.replace(\n\t\t\t/#include <fog_vertex>/,\n\t\t\t`\n\t\t\t#include <fog_vertex>\n\t\t\t`\n\t\t\t+ ShaderChunk.cityobjectdiffuse_vertex\n\t\t\t+ ShaderChunk.cityobjectshowlod_vertex\n\t\t);\n\t\tnewShader.fragmentShader =\n\t\t`\n\t\t\tvarying vec3 diffuse_;\n\t\t\tvarying float discard_;\n\t\t` +\n\t\tnewShader.fragmentShader.replace(\n\t\t\t/vec4 diffuseColor = vec4\\( diffuse, alpha \\);/,\n\t\t\t`\n\t\t\tvec4 diffuseColor = vec4( diffuse_, alpha );\n\n\t\t\t#ifdef SHOW_LOD\n\n\t\t\t\tif ( discard_ > 0.0 ) {\n\t\t\t\t\tdiscard;\n\t\t\t\t}\n\t\t\t\n\t\t\t#endif\n\t\t\t`\n\t\t);\n\n\t\tsuper( newShader );\n\n\t\tObject.defineProperties( this, {\n\n\t\t\tcolor: {\n\n\t\t\t\tenumerable: true,\n\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn this.uniforms.diffuse.value;\n\n\t\t\t\t},\n\n\t\t\t\tset: function ( value ) {\n\n\t\t\t\t\tthis.uniforms.diffuse.value = value;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tworldUnits: {\n\n\t\t\t\tenumerable: true,\n\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn 'WORLD_UNITS' in this.defines;\n\n\t\t\t\t},\n\n\t\t\t\tset: function ( value ) {\n\n\t\t\t\t\tif ( value === true ) {\n\n\t\t\t\t\t\tthis.defines.WORLD_UNITS = '';\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdelete this.defines.WORLD_UNITS;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tlinewidth: {\n\n\t\t\t\tenumerable: true,\n\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn this.uniforms.linewidth.value;\n\n\t\t\t\t},\n\n\t\t\t\tset: function ( value ) {\n\n\t\t\t\t\tthis.uniforms.linewidth.value = value;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tdashed: {\n\n\t\t\t\tenumerable: true,\n\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn Boolean( 'USE_DASH' in this.defines );\n\n\t\t\t\t},\n\n\t\t\t\tset( value ) {\n\n\t\t\t\t\tif ( Boolean( value ) !== Boolean( 'USE_DASH' in this.defines ) ) {\n\n\t\t\t\t\t\tthis.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( value === true ) {\n\n\t\t\t\t\t\tthis.defines.USE_DASH = '';\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdelete this.defines.USE_DASH;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tdashScale: {\n\n\t\t\t\tenumerable: true,\n\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn this.uniforms.dashScale.value;\n\n\t\t\t\t},\n\n\t\t\t\tset: function ( value ) {\n\n\t\t\t\t\tthis.uniforms.dashScale.value = value;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tdashSize: {\n\n\t\t\t\tenumerable: true,\n\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn this.uniforms.dashSize.value;\n\n\t\t\t\t},\n\n\t\t\t\tset: function ( value ) {\n\n\t\t\t\t\tthis.uniforms.dashSize.value = value;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tdashOffset: {\n\n\t\t\t\tenumerable: true,\n\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn this.uniforms.dashOffset.value;\n\n\t\t\t\t},\n\n\t\t\t\tset: function ( value ) {\n\n\t\t\t\t\tthis.uniforms.dashOffset.value = value;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tgapSize: {\n\n\t\t\t\tenumerable: true,\n\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn this.uniforms.gapSize.value;\n\n\t\t\t\t},\n\n\t\t\t\tset: function ( value ) {\n\n\t\t\t\t\tthis.uniforms.gapSize.value = value;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\topacity: {\n\n\t\t\t\tenumerable: true,\n\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn this.uniforms.opacity.value;\n\n\t\t\t\t},\n\n\t\t\t\tset: function ( value ) {\n\n\t\t\t\t\tthis.uniforms.opacity.value = value;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tresolution: {\n\n\t\t\t\tenumerable: true,\n\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn this.uniforms.resolution.value;\n\n\t\t\t\t},\n\n\t\t\t\tset: function ( value ) {\n\n\t\t\t\t\tthis.uniforms.resolution.value.copy( value );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\talphaToCoverage: {\n\n\t\t\t\tenumerable: true,\n\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn Boolean( 'USE_ALPHA_TO_COVERAGE' in this.defines );\n\n\t\t\t\t},\n\n\t\t\t\tset: function ( value ) {\n\n\t\t\t\t\tif ( Boolean( value ) !== Boolean( 'USE_ALPHA_TO_COVERAGE' in this.defines ) ) {\n\n\t\t\t\t\t\tthis.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( value === true ) {\n\n\t\t\t\t\t\tthis.defines.USE_ALPHA_TO_COVERAGE = '';\n\t\t\t\t\t\tthis.extensions.derivatives = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdelete this.defines.USE_ALPHA_TO_COVERAGE;\n\t\t\t\t\t\tthis.extensions.derivatives = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n}\n","import { ShaderChunk,\n\t\t ShaderLib,\n\t\t UniformsLib,\n\t\t UniformsUtils } from \"three\";\nimport 'three/examples/jsm/lines/LineMaterial.js';\nimport { CityObjectsBaseMaterial } from \"./CityObjectsBaseMaterial.js\";\n\nexport class CityObjectsPointsMaterial extends CityObjectsBaseMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tconst shader = ShaderLib.points;\n\n\t\tconst newShader = { ...shader };\n\t\tnewShader.uniforms = {\n\t\t\t...UniformsLib.cityobject,\n\t\t\t...UniformsUtils.clone( shader.uniforms ),\n\t\t};\n\t\tnewShader.extensions = {\n\t\t\tderivatives: true,\n\t\t};\n\t\tnewShader.lights = false;\n\t\tnewShader.vertexShader =\n\t\tShaderChunk.cityobjectinclude_vertex +\n\t\tnewShader.vertexShader.replace(\n\t\t\t/#include <fog_vertex>/,\n\t\t\t`\n\t\t\t#include <fog_vertex>\n\t\t\t`\n\t\t\t+ ShaderChunk.cityobjectdiffuse_vertex\n\t\t\t+ ShaderChunk.cityobjectshowlod_vertex\n\t\t);\n\t\tnewShader.fragmentShader =\n\t\t`\n\t\t\tvarying vec3 diffuse_;\n\t\t\tvarying float discard_;\n\t\t` +\n\t\tnewShader.fragmentShader.replace(\n\t\t\t/vec4 diffuseColor = vec4\\( diffuse, opacity \\);/,\n\t\t\t`\n\t\t\tvec4 diffuseColor = vec4( diffuse_, opacity );\n\n\t\t\t#ifdef SHOW_LOD\n\n\t\t\t\tif ( discard_ > 0.0 ) {\n\t\t\t\t\tdiscard;\n\t\t\t\t}\n\t\t\t\n\t\t\t#endif\n\t\t\t`\n\t\t);\n\n\t\tsuper( newShader, parameters );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tget size() {\n\n\t\treturn this.uniforms.size.value;\n\n\t}\n\n\tset size( value ) {\n\n\t\tthis.uniforms.size.value = value;\n\n\t}\n\n\tget sizeAttenuation() {\n\n\t\treturn Boolean( 'USE_SIZEATTENUATION' in this.defines );\n\n\t}\n\n\tset sizeAttenuation( value ) {\n\n\t\tif ( Boolean( value ) !== Boolean( 'USE_SIZEATTENUATION' in this.defines ) ) {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.defines.USE_SIZEATTENUATION = '';\n\n\t\t} else {\n\n\t\t\tdelete this.defines.USE_SIZEATTENUATION;\n\n\t\t}\n\n\t}\n\n}\n","import {\n\tVector3\n} from 'three';\nimport earcut from 'earcut';\n\nimport { TRIANGLES, GeometryData } from './GeometryData.js';\nimport { BaseParser } from './BaseParser.js';\n\nexport class TriangleParser extends BaseParser {\n\n\tconstructor( json, objectIds, objectColors, vertices ) {\n\n\t\tsuper( json, objectIds, objectColors );\n\n\t\tif ( vertices ) {\n\n\t\t\tthis.vertices = vertices;\n\n\t\t} else {\n\n\t\t\tthis.vertices = this.json.vertices;\n\n\t\t}\n\n\t\tthis.geomData = new GeometryData( TRIANGLES );\n\n\t}\n\n\tclean() {\n\n\t\tthis.geomData = new GeometryData( TRIANGLES );\n\n\t}\n\n\t/**\n\t * Flattens the given geometry, meaning that a Solid or MultiSolid will be\n\t * basically converted to a MultiSuface\n\t */\n\tflattenGeometry( geometry ) {\n\n\t\tconst geometryType = geometry.type;\n\n\t\tif ( geometryType == \"MultiSurface\" || geometryType == \"CompositeSurface\" ) {\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tif ( geometryType == \"Solid\" ) {\n\n\t\t\tconst newGeometry = Object.assign( {}, geometry );\n\n\t\t\tnewGeometry.boundaries = geometry.boundaries.flat( 1 );\n\n\t\t\tif ( geometry.semantics ) {\n\n\t\t\t\tnewGeometry.semantics.values = geometry.semantics.values.flat( 1 );\n\n\t\t\t}\n\n\t\t\tif ( geometry.material ) {\n\n\t\t\t\tfor ( const theme in geometry.material ) {\n\n\t\t\t\t\tnewGeometry.material[ theme ].values = geometry.material[ theme ].values.flat( 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( geometry.texture ) {\n\n\t\t\t\tfor ( const theme in geometry.texture ) {\n\n\t\t\t\t\tnewGeometry.texture[ theme ].values = geometry.texture[ theme ].values.flat( 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn newGeometry;\n\n\t\t}\n\n\t\tif ( geometryType == \"MultiSolid\" || geometryType == \"CompositeSolid\" ) {\n\n\t\t\tconst newGeometry = Object.assign( {}, geometry );\n\n\t\t\tnewGeometry.boundaries = geometry.boundaries.flat( 2 );\n\n\t\t\tif ( geometry.semantics ) {\n\n\t\t\t\tnewGeometry.semantics.values = geometry.semantics.values.flat( 2 );\n\n\t\t\t}\n\n\t\t\tif ( geometry.material ) {\n\n\t\t\t\tfor ( const theme in geometry.material ) {\n\n\t\t\t\t\tnewGeometry.material[ theme ].values = geometry.material[ theme ].values.flat( 2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( geometry.texture ) {\n\n\t\t\t\tfor ( const theme in geometry.texture ) {\n\n\t\t\t\t\tnewGeometry.texture[ theme ].values = geometry.texture[ theme ].values.flat( 2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn newGeometry;\n\n\t\t}\n\n\t}\n\n\tparseGeometry( geometry, objectId, geomIdx ) {\n\n\t\tconst cityObj = this.json.CityObjects[ objectId ];\n\n\t\tconst idIdx = cityObj ? this.getObjectIdx( objectId ) : - 1;\n\t\tconst objType = cityObj ? this.getObjectTypeIdx( cityObj.type ) : - 1;\n\t\tconst lodIdx = this.getLodIndex( geometry.lod );\n\n\t\t// We flatten the geometry to a MultiSurface, basically, so that it's\n\t\t// easily parsable.\n\t\tconst flatGeometry = this.flattenGeometry( geometry );\n\n\t\tif ( flatGeometry ) {\n\n\t\t\tthis.parseShell( flatGeometry, idIdx, objType, geomIdx, lodIdx );\n\n\t\t}\n\n\n\t}\n\n\tparseShell( geometry, idIdx, objType, geomIdx, lodIdx ) {\n\n\t\tconst boundaries = geometry.boundaries;\n\t\tconst semantics = geometry.semantics ? geometry.semantics.values : [];\n\t\tconst surfaces = geometry.semantics ? geometry.semantics.surfaces : [];\n\t\tconst material = geometry.material ? geometry.material : {};\n\t\tconst texture = geometry.texture ? geometry.texture : {};\n\n\t\t// Contains the boundary but with the right verticeId\n\t\tfor ( let i = 0; i < boundaries.length; i ++ ) {\n\n\t\t\tlet boundary = [];\n\t\t\tlet holes = [];\n\n\t\t\tconst surfaceType = this.getSurfaceTypeIdx( i, semantics, surfaces );\n\t\t\tconst materialValue = this.getSurfaceMaterials( i, material );\n\n\t\t\tfor ( let j = 0; j < boundaries[ i ].length; j ++ ) {\n\n\t\t\t\tif ( boundary.length > 0 ) {\n\n\t\t\t\t\tholes.push( boundary.length );\n\n\t\t\t\t}\n\n\t\t\t\t// const new_boundary = this.extractLocalIndices( geom, boundaries[ i ][ j ], vertices, json );\n\t\t\t\t// boundary.push( ...new_boundary );\n\t\t\t\tboundary.push( ...boundaries[ i ][ j ] );\n\n\t\t\t}\n\n\t\t\tif ( boundary.length == 3 ) {\n\n\t\t\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\t\t\tthis.geomData.addVertex( boundary[ n ],\n\t\t\t\t\t\t\t\t\t\t\t idIdx,\n\t\t\t\t\t\t\t\t\t\t\t objType,\n\t\t\t\t\t\t\t\t\t\t\t surfaceType,\n\t\t\t\t\t\t\t\t\t\t\t geomIdx,\n\t\t\t\t\t\t\t\t\t\t\t i,\n\t\t\t\t\t\t\t\t\t\t\t lodIdx,\n\t\t\t\t\t\t\t\t\t\t\t materialValue,\n\t\t\t\t\t\t\t\t\t\t\t this.getTextureData( i, n, holes, texture ) );\n\n\t\t\t\t}\n\n\n\t\t\t} else if ( boundary.length > 3 ) {\n\n\t\t\t\t//create list of points\n\t\t\t\tlet pList = [];\n\t\t\t\tfor ( let k = 0; k < boundary.length; k ++ ) {\n\n\t\t\t\t\tpList.push( {\n\t\t\t\t\t\tx: this.vertices[ boundary[ k ] ][ 0 ],\n\t\t\t\t\t\ty: this.vertices[ boundary[ k ] ][ 1 ],\n\t\t\t\t\t\tz: this.vertices[ boundary[ k ] ][ 2 ]\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\t//get normal of these points\n\t\t\t\tconst normal = this.getNewellsNormal( pList );\n\n\t\t\t\t//convert to 2d (for triangulation)\n\t\t\t\tlet pv = [];\n\t\t\t\tfor ( let k = 0; k < pList.length; k ++ ) {\n\n\t\t\t\t\tconst re = this.to_2d( pList[ k ], normal );\n\t\t\t\t\tpv.push( re.x );\n\t\t\t\t\tpv.push( re.y );\n\n\t\t\t\t}\n\n\t\t\t\t//triangulate\n\t\t\t\tconst tr = earcut( pv, holes, 2 );\n\n\t\t\t\t// create faces based on triangulation\n\t\t\t\tfor ( let k = 0; k < tr.length; k += 3 ) {\n\n\t\t\t\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\t\t\t\tconst vertex = boundary[ tr[ k + n ] ];\n\n\t\t\t\t\t\tthis.geomData.addVertex( vertex,\n\t\t\t\t\t\t\t\t\t\t\t \t idIdx,\n\t\t\t\t\t\t\t\t\t\t\t\t objType,\n\t\t\t\t\t\t\t\t\t\t\t\t surfaceType,\n\t\t\t\t\t\t\t\t\t\t\t\t geomIdx,\n\t\t\t\t\t\t\t\t\t\t\t\t i,\n\t\t\t\t\t\t\t\t\t\t\t\t lodIdx,\n\t\t\t\t\t\t\t\t\t\t\t\t materialValue,\n\t\t\t\t\t\t\t\t\t\t\t\t this.getTextureData( i, tr[ k + n ], holes, texture ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tgetNewellsNormal( indices ) {\n\n\t\t// find normal with Newell's method\n\t\tlet n = [ 0.0, 0.0, 0.0 ];\n\n\t\tfor ( let i = 0; i < indices.length; i ++ ) {\n\n\t\t\tlet nex = i + 1;\n\n\t\t\tif ( nex == indices.length ) {\n\n\t\t\t\tnex = 0;\n\n\t\t\t}\n\n\t\t\tn[ 0 ] = n[ 0 ] + ( ( indices[ i ].y - indices[ nex ].y ) * ( indices[ i ].z + indices[ nex ].z ) );\n\t\t\tn[ 1 ] = n[ 1 ] + ( ( indices[ i ].z - indices[ nex ].z ) * ( indices[ i ].x + indices[ nex ].x ) );\n\t\t\tn[ 2 ] = n[ 2 ] + ( ( indices[ i ].x - indices[ nex ].x ) * ( indices[ i ].y + indices[ nex ].y ) );\n\n\t\t}\n\n\t\tlet b = new Vector3( n[ 0 ], n[ 1 ], n[ 2 ] );\n\t\treturn ( b.normalize() );\n\n\t}\n\n\tto_2d( p, n ) {\n\n\t\tp = new Vector3( p.x, p.y, p.z );\n\t\tlet x3 = new Vector3( 1.1, 1.1, 1.1 );\n\t\tif ( x3.distanceTo( n ) < 0.01 ) {\n\n\t\t\tx3.add( new Vector3( 1.0, 2.0, 3.0 ) );\n\n\t\t}\n\n\t\tlet tmp = x3.dot( n );\n\t\tlet tmp2 = n.clone();\n\t\ttmp2.multiplyScalar( tmp );\n\t\tx3.sub( tmp2 );\n\t\tx3.normalize();\n\t\tlet y3 = n.clone();\n\t\ty3.cross( x3 );\n\t\tlet x = p.dot( x3 );\n\t\tlet y = p.dot( y3 );\n\t\tlet re = { x: x, y: y };\n\t\treturn re;\n\n\t}\n\n}\n","import { defaultSemanticsColors } from '../../defaults/colors.js';\n\nexport class BaseParser {\n\n\tconstructor( json, objectIds, objectColors ) {\n\n\t\tthis.json = json;\n\n\t\tthis.objectIds = objectIds;\n\t\tthis.objectColors = objectColors;\n\t\tthis.surfaceColors = defaultSemanticsColors;\n\t\tthis.lods = [];\n\n\t}\n\n\tclean() { }\n\n\tparseGeometry( geometry, objectId, geomIdx ) {}\n\n\tgetObjectIdx( objectId ) {\n\n\t\treturn this.objectIds.indexOf( objectId );\n\n\t}\n\n\tgetObjectTypeIdx( cityObjectTypeName ) {\n\n\t\tlet objType = Object.keys( this.objectColors ).indexOf( cityObjectTypeName );\n\n\t\tif ( objType < 0 ) {\n\n\t\t\tobjType = Object.keys( this.objectColors ).length;\n\t\t\tthis.objectColors[ cityObjectTypeName ] = Math.floor( Math.random() * 0xffffff );\n\n\t\t}\n\n\t\treturn objType;\n\n\t}\n\n\tgetSurfaceTypeIdx( idx, semantics, surfaces ) {\n\n\t\tlet surfaceType = - 1;\n\t\tif ( semantics.length > 0 ) {\n\n\t\t\tconst surface = surfaces[ semantics[ idx ] ];\n\n\t\t\tif ( surface ) {\n\n\t\t\t\tsurfaceType = Object.keys( this.surfaceColors ).indexOf( surface.type );\n\n\t\t\t\tif ( surfaceType < 0 ) {\n\n\t\t\t\t\tsurfaceType = Object.keys( this.surfaceColors ).length;\n\t\t\t\t\tthis.surfaceColors[ surface.type ] = Math.floor( Math.random() * 0xffffff );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn surfaceType;\n\n\t}\n\n\tgetSurfaceMaterials( idx, material ) {\n\n\t\tconst pairs = Object.entries( material ).map( mat => {\n\n\t\t\tconst [ theme, obj ] = mat;\n\n\t\t\tif ( obj.values ) {\n\n\t\t\t\treturn [ theme, obj.values[ idx ] ];\n\n\t\t\t} else if ( obj.value !== undefined ) {\n\n\t\t\t\treturn [ theme, obj.value ];\n\n\t\t\t} else {\n\n\t\t\t\treturn [ theme, - 1 ];\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn Object.fromEntries( pairs );\n\n\t}\n\n\tgetTextureData( surfaceIndex, vertexIndex, holes, texture ) {\n\n\t\tif ( this.json.appearance && this.json.appearance[ 'vertices-texture' ] ) {\n\n\t\t\tconst textureVertices = this.json.appearance[ 'vertices-texture' ];\n\n\t\t\tconst pairs = Object.entries( texture ).map( tex => {\n\n\t\t\t\tconst [ theme, obj ] = tex;\n\n\t\t\t\tif ( obj.values ) {\n\n\t\t\t\t\tconst activeHoles = holes.filter( v => v <= vertexIndex );\n\n\t\t\t\t\tconst ringId = activeHoles.length;\n\t\t\t\t\tconst vId = ringId ? vertexIndex - activeHoles[ activeHoles.length - 1 ] : vertexIndex;\n\n\t\t\t\t\t// TODO: This is very delicate\n\t\t\t\t\tconst data = obj.values[ surfaceIndex ];\n\n\t\t\t\t\tif ( data[ 0 ][ 0 ] !== null ) {\n\n\t\t\t\t\t\tconst uvs = textureVertices[ data[ ringId ][ vId + 1 ] ];\n\n\t\t\t\t\t\treturn [ theme, { index: data[ 0 ][ 0 ], uvs } ];\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\treturn [ theme, { index: - 1, uvs: [ 0, 0 ] } ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn [ theme, { index: - 1, uvs: [ 0, 0 ] } ];\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn Object.fromEntries( pairs );\n\n\t\t}\n\n\t\treturn undefined;\n\n\t}\n\n\tgetLodIndex( lod ) {\n\n\t\tif ( lod === undefined ) {\n\n\t\t\treturn - 1;\n\n\t\t}\n\n\t\tconst lodIdx = this.lods.indexOf( lod );\n\n\t\tif ( lodIdx < 0 ) {\n\n\t\t\tconst newIdx = this.lods.length;\n\t\t\tthis.lods.push( lod );\n\t\t\treturn newIdx;\n\n\t\t}\n\n\t\treturn lodIdx;\n\n\t}\n\n}\n","import { LINES, GeometryData } from './GeometryData.js';\nimport { BaseParser } from './BaseParser.js';\n\nexport class LineParser extends BaseParser {\n\n\tconstructor( json, objectIds, objectColors ) {\n\n\t\tsuper( json, objectIds, objectColors );\n\n\t\tthis.geomData = new GeometryData( LINES );\n\n\t}\n\n\tclean() {\n\n\t\tthis.geomData = new GeometryData( LINES );\n\n\t}\n\n\thandles( geometry ) {\n\n\t\treturn geometry.type == \"MultiLineString\";\n\n\t}\n\n\tparseGeometry( geometry, objectId, geomIdx ) {\n\n\t\tconst semanticSurfaces = geometry.semantics ? geometry.semantics.surfaces : [];\n\n\t\tif ( geometry.type == \"MultiLineString\" ) {\n\n\t\t\tconst cityObj = this.json.CityObjects[ objectId ];\n\n\t\t\tconst idIdx = this.getObjectIdx( objectId );\n\n\t\t\tconst objType = this.getObjectTypeIdx( cityObj.type );\n\n\t\t\tconst lodIdx = this.getLodIndex( cityObj.geometry[ geomIdx ].lod );\n\n\t\t\tconst linestrings = geometry.boundaries;\n\n\t\t\tfor ( let i = 0; i < linestrings.length; i ++ ) {\n\n\t\t\t\tif ( linestrings[ i ].length > 1 ) {\n\n\t\t\t\t\tconst semantics = geometry.semantics ? geometry.semantics.values : [];\n\t\t\t\t\tconst surfaceType = this.getSurfaceTypeIdx( i, semantics, semanticSurfaces );\n\n\t\t\t\t\tconst linestring = linestrings[ i ];\n\n\t\t\t\t\t// Contains the boundary but with the right verticeId\n\t\t\t\t\tfor ( let j = 0; j < linestrings[ i ].length - 1; j ++ ) {\n\n\t\t\t\t\t\tthis.geomData.addVertex( linestring[ j ],\n\t\t\t\t\t\t\tidIdx,\n\t\t\t\t\t\t\tobjType,\n\t\t\t\t\t\t\tsurfaceType,\n\t\t\t\t\t\t\tgeomIdx,\n\t\t\t\t\t\t\ti,\n\t\t\t\t\t\t\tlodIdx );\n\n\t\t\t\t\t\tthis.geomData.addVertex( linestring[ j + 1 ],\n\t\t\t\t\t\t\tidIdx,\n\t\t\t\t\t\t\tobjType,\n\t\t\t\t\t\t\tsurfaceType,\n\t\t\t\t\t\t\tgeomIdx,\n\t\t\t\t\t\t\ti,\n\t\t\t\t\t\t\tlodIdx );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n","import { POINTS, GeometryData } from './GeometryData.js';\nimport { BaseParser } from './BaseParser.js';\n\nexport class PointParser extends BaseParser {\n\n\tconstructor( json, objectIds, objectColors ) {\n\n\t\tsuper( json, objectIds, objectColors );\n\n\t\tthis.geomData = new GeometryData( POINTS );\n\n\t}\n\n\tclean() {\n\n\t\tthis.geomData = new GeometryData( POINTS );\n\n\t}\n\n\thandles( geometry ) {\n\n\t\treturn geometry.type == \"MultiPoint\";\n\n\t}\n\n\tparseGeometry( geometry, objectId, geomIdx ) {\n\n\t\tconst semanticSurfaces = geometry.semantics ? geometry.semantics.surfaces : [];\n\n\t\tif ( geometry.type == \"MultiPoint\" ) {\n\n\t\t\tconst cityObj = this.json.CityObjects[ objectId ];\n\n\t\t\tconst idIdx = this.getObjectIdx( objectId );\n\n\t\t\tconst objType = this.getObjectTypeIdx( cityObj.type );\n\n\t\t\tconst lodIdx = this.getLodIndex( cityObj.geometry[ geomIdx ].lod );\n\n\t\t\tconst points = geometry.boundaries;\n\n\t\t\tfor ( let i = 0; i < points.length; i ++ ) {\n\n\t\t\t\tconst semantics = geometry.semantics ? geometry.semantics.values : [];\n\t\t\t\tconst surfaceType = this.getSurfaceTypeIdx( i, semantics, semanticSurfaces );\n\n\t\t\t\tthis.geomData.addVertex( points[ i ],\n\t\t\t\t\tidIdx,\n\t\t\t\t\tobjType,\n\t\t\t\t\tsurfaceType,\n\t\t\t\t\tgeomIdx,\n\t\t\t\t\ti,\n\t\t\t\t\tlodIdx );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n","import { InstancedBufferGeometry } from 'three';\nimport { InstancedBufferAttribute } from 'three';\nimport { BufferAttribute,\n\t\t InstancedMesh,\n\t\t Int32BufferAttribute } from 'three';\n\nexport class CityObjectsInstancedMesh extends InstancedMesh {\n\n\tconstructor( citymodel, vertices, geometryData, instanceData, matrix, material ) {\n\n\t\tconst geom = new InstancedBufferGeometry();\n\n\t\tconst vertexArray = new Float32Array( vertices );\n\t\tgeom.setAttribute( 'position', new BufferAttribute( vertexArray, 3 ) );\n\t\tconst idsArray = new Uint16Array( instanceData.objectIds );\n\t\tgeom.setAttribute( 'objectid', new InstancedBufferAttribute( idsArray, 1 ) );\n\t\tconst typeArray = new Int32Array( instanceData.objectType );\n\t\tgeom.setAttribute( 'type', new InstancedBufferAttribute( typeArray, 1 ) );\n\t\tconst surfaceTypeArray = new Int8Array( geometryData.semanticSurfaces );\n\t\tgeom.setAttribute( 'surfacetype', new Int32BufferAttribute( surfaceTypeArray, 1 ) );\n\t\tconst geomIdsArray = new Float32Array( instanceData.geometryIds );\n\t\tgeom.setAttribute( 'geometryid', new InstancedBufferAttribute( geomIdsArray, 1 ) );\n\t\tconst lodIdsArray = new Int8Array( geometryData.lodIds );\n\t\tgeom.setAttribute( 'lodid', new BufferAttribute( lodIdsArray, 1 ) );\n\t\tconst boundaryIdsArray = new Float32Array( geometryData.boundaryIds );\n\t\tgeom.setAttribute( 'boundaryid', new BufferAttribute( boundaryIdsArray, 1 ) );\n\n\t\tfor ( const material in geometryData.materials ) {\n\n\t\t\tconst materialArray = new Uint8Array( geometryData.materials[ material ] );\n\t\t\tgeom.setAttribute( `mat${material}`, new Int32BufferAttribute( materialArray, 1 ) );\n\n\t\t}\n\n\t\tgeom.attributes.position.needsUpdate = true;\n\n\t\tif ( matrix ) {\n\n\t\t\tgeom.applyMatrix4( matrix );\n\n\t\t}\n\n\t\tgeom.computeVertexNormals();\n\n\t\tsuper( geom, material, instanceData.matrices.length );\n\n\t\tfor ( let j = 0; j < instanceData.matrices.length; j ++ ) {\n\n\t\t\tthis.setMatrixAt( j, instanceData.matrices[ j ] );\n\n\t\t}\n\n\t\tthis.citymodel = citymodel;\n\n\t\tthis.isCityObject = true;\n\t\tthis.isCityObjectMesh = true;\n\n\t\tthis.supportsConditionalFormatting = true;\n\t\tthis.supportsMaterials = true;\n\n\t}\n\n\tsetArrayAsAttribute( array ) {\n\n\t\tthis.geometry.setAttribute( 'attributevalue', new InstancedBufferAttribute( new Int32Array( array ), 1 ) );\n\n\t}\n\n\taddAttributeByProperty( attributeEvaluator ) {\n\n\t\tconst allValues = attributeEvaluator.getAllValues();\n\t\tconst uniqueValues = attributeEvaluator.getUniqueValues();\n\n\t\tif ( uniqueValues.length < 110 ) {\n\n\t\t\tconst objectLookup = [];\n\t\t\tfor ( const value of allValues ) {\n\n\t\t\t\tobjectLookup.push( uniqueValues.indexOf( value ) );\n\n\t\t\t}\n\n\t\t\tconst objectIds = this.geometry.attributes.objectid.array;\n\n\t\t\tconst finalArray = objectIds.map( i => {\n\n\t\t\t\treturn objectLookup[ i ];\n\n\t\t\t} );\n\n\t\t\tif ( finalArray.length !== objectIds.length ) {\n\n\t\t\t\tconsole.warn( \"Wrong size of attributes array.\" );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.setArrayAsAttribute( finalArray );\n\n\t\t}\n\n\t}\n\n\tgetIntersectionVertex( intersection ) {\n\n\t\treturn intersection.face.a;\n\n\t}\n\n\tresolveIntersectionInfo( intersection ) {\n\n\t\tconst intersectionInfo = {};\n\n\t\tconst vertexIdx = this.getIntersectionVertex( intersection );\n\t\tconst instanceId = intersection.instanceId;\n\n\t\tconst idx = this.geometry.getAttribute( 'objectid' ).getX( instanceId );\n\n\t\tintersectionInfo.vertexIndex = vertexIdx;\n\t\tintersectionInfo.objectIndex = idx;\n\t\tintersectionInfo.objectId = Object.keys( this.citymodel.CityObjects )[ idx ];\n\t\tintersectionInfo.geometryIndex = this.geometry.getAttribute( 'geometryid' ).getX( instanceId );\n\t\tintersectionInfo.boundaryIndex = this.geometry.getAttribute( 'boundaryid' ).getX( vertexIdx );\n\n\t\tintersectionInfo.objectTypeIndex = this.geometry.getAttribute( 'type' ).getX( instanceId );\n\t\tintersectionInfo.surfaceTypeIndex = this.geometry.getAttribute( 'surfacetype' ).getX( vertexIdx );\n\t\tintersectionInfo.lodIndex = this.geometry.getAttribute( 'lodid' ).getX( vertexIdx );\n\n\t\treturn intersectionInfo;\n\n\t}\n\n\tsetTextureTheme( theme, textureManager ) {\n\n\t\tif ( theme === \"undefined\" ) {\n\n\t\t\tthis.unsetTextures();\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst themeName = theme.replace( /[^a-z0-9]/gi, '' );\n\n\t\tconst attributeName = `tex${themeName}`;\n\n\t\tif ( attributeName in this.geometry.attributes ) {\n\n\t\t\tconst textureIds = this.geometry.attributes[ attributeName ].array;\n\n\t\t\t// Create a lookup of textures\n\t\t\tconst { values, indices } = textureIds.reduce( ( p, c, i ) => {\n\n\t\t\t\tif ( p.last !== c ) {\n\n\t\t\t\t\tp.values.push( c );\n\t\t\t\t\tp.indices.push( i );\n\t\t\t\t\tp.last = c;\n\n\t\t  \t\t}\n\n\t\t  \t\treturn p;\n\n\t\t\t}, { last: - 1, values: [], indices: [] } );\n\n\t\t\tconst baseMaterial = Array.isArray( this.material ) ? this.material[ this.material.length - 1 ] : this.material;\n\n\t\t\tconst materials = textureManager.getMaterials( baseMaterial );\n\n\t\t\tfor ( const mat of materials ) {\n\n\t\t\t\tif ( mat !== baseMaterial ) {\n\n\t\t\t\t\tmat.textureTheme = theme;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// TODO: We need to add the last element here\n\t\t\tfor ( let i = 0; i < indices.length - 1; i ++ ) {\n\n\t\t\t\tthis.geometry.addGroup( indices[ i ], indices[ i + 1 ] - indices[ i ], values[ i ] > - 1 ? values[ i ] : materials.length - 1 );\n\n\t\t\t}\n\n\t\t\tconst i = indices.length - 1;\n\n\t\t\tthis.geometry.addGroup( indices[ i ], this.geometry.attributes.type.array.length - indices[ i ], values[ i ] > - 1 ? values[ i ] : materials.length - 1 );\n\n\t\t\tthis.material = materials;\n\n\t\t}\n\n\t}\n\n\tunsetTextures() {\n\n\t\tif ( Array.isArray( this.material ) ) {\n\n\t\t\tthis.material = this.material[ this.material.length - 1 ];\n\n\t\t}\n\n\t\tthis.material.textureTheme = \"undefined\";\n\n\t}\n\n}\n","import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tMesh,\n\tMeshLambertMaterial,\n\tVector3 } from 'three';\nimport earcut from 'earcut';\n\nexport class ObjectMaterialParser {\n\n\tconstructor( materialTheme ) {\n\n\t\tthis.matrix = null;\n\n\t\tthis.meshVertices = [];\n\t\tthis.meshTriangles = [];\n\t\tthis.meshTriangleIDs = [];\n\n\t\tthis.materials = [];\n\t\tthis.materialTheme = materialTheme;\n\n\t\tthis.defaultMaterial = new MeshLambertMaterial();\n\t\tthis.defaultMaterial.color.setHex( 0xcccccc );\n\n\t}\n\n\tparse( data, scene ) {\n\n\t\tif ( \"appearance\" in data && \"materials\" in data.appearance ) {\n\n\t\t\tthis.materials = data.appearance.materials;\n\n\t\t} else {\n\n\t\t\tthis.materials = [];\n\n\t\t}\n\n\t\tfor ( let i = 0; i < this.materials.length; i ++ ) {\n\n\t\t\tthis.meshVertices[ i ] = [];\n\t\t\tthis.meshTriangles[ i ] = [];\n\t\t\tthis.meshTriangleIDs[ i ] = [];\n\n\t\t}\n\n\t\tthis.meshVertices[ this.materials.length ] = [];\n\t\tthis.meshTriangles[ this.materials.length ] = [];\n\t\tthis.meshTriangleIDs[ this.materials.length ] = [];\n\n\t\tfor ( const objectId in data.CityObjects ) {\n\n\t\t\tthis.parseObject( objectId, data );\n\n\t\t}\n\n\t\tfor ( let i = 0; i <= this.materials.length; i ++ ) {\n\n\t\t\tif ( this.meshVertices[ i ].length == 0 ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst geom = new BufferGeometry();\n\n\t\t\tlet vertices = [];\n\n\t\t\tgeom.setIndex( this.meshTriangles[ i ] );\n\n\t\t\tfor ( const vertexIndex of this.meshVertices[ i ] ) {\n\n\t\t\t\tconst vertex = data.vertices[ vertexIndex ];\n\n\t\t\t\tvertices.push( ...vertex );\n\n\t\t\t}\n\n\t\t\tconst vertexArray = new Float32Array( vertices );\n\t\t\tgeom.setAttribute( 'position', new BufferAttribute( vertexArray, 3 ) );\n\n\t\t\tgeom.getAttribute( 'position' ).needsUpdate = true;\n\n\t\t\tif ( this.matrix !== null ) {\n\n\t\t\t\tgeom.applyMatrix4( this.matrix );\n\n\t\t\t}\n\n\t\t\tgeom.computeVertexNormals();\n\n\t\t\tlet material = new MeshLambertMaterial();\n\t\t\tif ( i < this.materials.length ) {\n\n\t\t\t\tmaterial.color.setRGB( ...this.materials[ i ].diffuseColor );\n\n\t\t\t} else {\n\n\t\t\t\tmaterial = this.defaultMaterial;\n\n\t\t\t}\n\n\t\t\tconst mesh = new Mesh( geom, material );\n\t\t\tif ( i < this.materials.length ) {\n\n\t\t\t\tmesh.name = this.materials[ i ].name;\n\n\t\t\t} else {\n\n\t\t\t\tmesh.name = \"Default\";\n\n\t\t\t}\n\n\t\t\tmesh.castShadow = true;\n\t\t\tmesh.receiveShadow = true;\n\n\t\t\tmesh.triangleIDs = this.meshTriangleIDs[ i ];\n\n\t\t\tscene.add( mesh );\n\n\t\t}\n\n\t}\n\n\tparseObject( objectId, json ) {\n\n\t\tconst cityObject = json.CityObjects[ objectId ];\n\n\t\tif ( ! ( cityObject.geometry &&\n                cityObject.geometry.length > 0 ) ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// TODO: Create a fake all `null` array if the 'material' array doesn't exist in the object.\n\n\t\tfor ( let geom_i = 0; geom_i < cityObject.geometry.length; geom_i ++ ) {\n\n\t\t\tconst geomType = cityObject.geometry[ geom_i ].type;\n\n\t\t\tif ( geomType == \"Solid\" ) {\n\n\t\t\t\tconst shells = cityObject.geometry[ geom_i ].boundaries;\n\t\t\t\tconst materialShells = this.getMaterialValues( cityObject.geometry[ geom_i ] );\n\n\t\t\t\tfor ( let i = 0; i < shells.length; i ++ ) {\n\n\t\t\t\t\tthis.parseShell( shells[ i ], materialShells === null ? null : materialShells[ i ], objectId, json );\n\n\t\t\t\t}\n\n\t\t\t} else if ( geomType == \"MultiSurface\" || geomType == \"CompositeSurface\" ) {\n\n\t\t\t\tconst surfaces = cityObject.geometry[ geom_i ].boundaries;\n\t\t\t\tconst materialShell = this.getMaterialValues( cityObject.geometry[ geom_i ] );\n\n\t\t\t\tthis.parseShell( surfaces, materialShell, objectId, json );\n\n\t\t\t} else if ( geomType == \"MultiSolid\" || geomType == \"CompositeSolid\" ) {\n\n\t\t\t\tconst solids = cityObject.geometry[ geom_i ].boundaries;\n\t\t\t\tconst materialShells = this.getMaterialValues( cityObject.geometry[ geom_i ] );\n\n\t\t\t\tfor ( let i = 0; i < solids.length; i ++ ) {\n\n\t\t\t\t\tfor ( let j = 0; j < solids[ i ].length; j ++ ) {\n\n\t\t\t\t\t\tthis.parseShell( solids[ i ][ j ], materialShells === null ? null : materialShells[ i ][ j ], objectId, json );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tgetMaterialValues( geometry ) {\n\n\t\tif ( \"material\" in geometry ) {\n\n\t\t\treturn geometry.material[ this.materialTheme ].values;\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\tparseShell( boundaries, materialValues, id, json ) {\n\n\t\t// Contains the boundary but with the right verticeId\n\t\tfor ( let i = 0; i < boundaries.length; i ++ ) {\n\n\t\t\tlet boundary = [];\n\t\t\tlet holes = [];\n\n\t\t\tlet vertices;\n\t\t\tlet triangles;\n\t\t\tlet ids;\n\t\t\tif ( materialValues === null || materialValues[ i ] === null ) {\n\n\t\t\t\tvertices = this.meshVertices[ this.materials.length ];\n\t\t\t\ttriangles = this.meshTriangles[ this.materials.length ];\n\t\t\t\tids = this.meshTriangleIDs[ this.materials.length ];\n\n\t\t\t} else {\n\n\t\t\t\tvertices = this.meshVertices[ materialValues[ i ] ];\n\t\t\t\ttriangles = this.meshTriangles[ materialValues[ i ] ];\n\t\t\t\tids = this.meshTriangleIDs[ materialValues[ i ] ];\n\n\t\t\t}\n\n\t\t\tfor ( let j = 0; j < boundaries[ i ].length; j ++ ) {\n\n\t\t\t\tif ( boundary.length > 0 ) {\n\n\t\t\t\t\tholes.push( boundary.length );\n\n\t\t\t\t}\n\n\t\t\t\tboundary.push( ...boundaries[ i ][ j ] );\n\n\t\t\t}\n\n\t\t\tif ( boundary.length == 3 ) {\n\n\t\t\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\t\t\tconst index = vertices.indexOf( boundary[ n ] );\n\n\t\t\t\t\tif ( index == - 1 ) {\n\n\t\t\t\t\t\ttriangles.push( vertices.length );\n\t\t\t\t\t\tvertices.push( boundary[ n ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttriangles.push( index );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tids.push( id );\n\n\t\t\t\t}\n\n\n\t\t\t} else if ( boundary.length > 3 ) {\n\n\t\t\t\t//create list of points\n\t\t\t\tlet pList = [];\n\t\t\t\tfor ( let k = 0; k < boundary.length; k ++ ) {\n\n\t\t\t\t\tpList.push( {\n\t\t\t\t\t\tx: json.vertices[ boundary[ k ] ][ 0 ],\n\t\t\t\t\t\ty: json.vertices[ boundary[ k ] ][ 1 ],\n\t\t\t\t\t\tz: json.vertices[ boundary[ k ] ][ 2 ]\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\t//get normal of these points\n\t\t\t\tconst normal = this.get_normal_newell( pList );\n\n\t\t\t\t//convert to 2d (for triangulation)\n\t\t\t\tlet pv = [];\n\t\t\t\tfor ( let k = 0; k < pList.length; k ++ ) {\n\n\t\t\t\t\tconst re = this.to_2d( pList[ k ], normal );\n\t\t\t\t\tpv.push( re.x );\n\t\t\t\t\tpv.push( re.y );\n\n\t\t\t\t}\n\n\t\t\t\t//triangulate\n\t\t\t\tconst tr = earcut( pv, holes, 2 );\n\n\t\t\t\t// create faces based on triangulation\n\t\t\t\tfor ( let k = 0; k < tr.length; k += 3 ) {\n\n\t\t\t\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\t\t\t\tconst vertex = boundary[ tr[ k + n ] ];\n\t\t\t\t\t\tconst index = vertices.indexOf( vertex );\n\n\t\t\t\t\t\tif ( index == - 1 ) {\n\n\t\t\t\t\t\t\ttriangles.push( vertices.length );\n\t\t\t\t\t\t\tvertices.push( vertex );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttriangles.push( index );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\textractLocalIndices( geom, boundary, indices, json ) {\n\n\t\tlet new_boundary = [];\n\n\t\tlet j;\n\t\tfor ( j = 0; j < boundary.length; j ++ ) {\n\n\t\t\t//the original index from the json file\n\t\t\tlet index = boundary[ j ];\n\n\t\t\t//if this index is already there\n\t\t\tif ( indices.includes( index ) ) {\n\n\t\t\t\tlet vertPos = indices.indexOf( index );\n\t\t\t\tnew_boundary.push( vertPos );\n\n\t\t\t} else {\n\n\t\t\t\t// Add vertex to geometry\n\t\t\t\tlet point = new THREE.Vector3(\n\t\t\t\t\tjson.vertices[ index ][ 0 ],\n\t\t\t\t\tjson.vertices[ index ][ 1 ],\n\t\t\t\t\tjson.vertices[ index ][ 2 ]\n\t\t\t\t);\n\t\t\t\tgeom.vertices.push( point );\n\n\t\t\t\tnew_boundary.push( indices.length );\n\t\t\t\tindices.push( index );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn new_boundary;\n\n\t}\n\n\tgetBbox( data ) {\n\n\t\tlet bbox;\n\n\t\tif ( data[ \"metadata\" ] != undefined && data[ \"metadata\" ][ \"geographicalExtent\" ] != undefined ) {\n\n\n\t\t\tbbox = data[ \"metadata\" ][ \"geographicalExtent\" ];\n\n\t\t\tif ( data[ \"transform\" ] != undefined ) {\n\n\t\t\t\tconst transform = data[ \"transform\" ];\n\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tbbox[ i ] = bbox[ i ] - transform[ \"translate\" ][ i ];\n\t\t\t\t\tbbox[ i + 3 ] = ( bbox[ i + 3 ] - transform[ \"translate\" ][ i ] ) / transform[ \"scale\" ][ i ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t} else {\n\n\t\t\tconst vertices = data.vertices;\n\n\t\t\tbbox = [ Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE ];\n\n\t\t\tfor ( const v of vertices ) {\n\n\t\t\t\tconst x = v[ 0 ];\n\t\t\t\tconst y = v[ 1 ];\n\t\t\t\tconst z = v[ 2 ];\n\n\t\t\t\tif ( x < bbox[ 0 ] ) {\n\n\t\t\t\t\tbbox[ 0 ] = x;\n\n\t\t\t\t} else if ( x > bbox[ 3 ] ) {\n\n\t\t\t\t\tbbox[ 3 ] = x;\n\n\t\t\t\t}\n\n\t\t\t\tif ( y < bbox[ 1 ] ) {\n\n\t\t\t\t\tbbox[ 1 ] = y;\n\n\t\t\t\t} else if ( y > bbox[ 4 ] ) {\n\n\t\t\t\t\tbbox[ 4 ] = y;\n\n\t\t\t\t}\n\n\t\t\t\tif ( z < bbox[ 2 ] ) {\n\n\t\t\t\t\tbbox[ 2 ] = z;\n\n\t\t\t\t} else if ( z > bbox[ 5 ] ) {\n\n\t\t\t\t\tbbox[ 5 ] = z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bbox;\n\n\t}\n\n\tget_normal_newell( indices ) {\n\n\t\t// find normal with Newell's method\n\t\tlet n = [ 0.0, 0.0, 0.0 ];\n\n\t\tfor ( let i = 0; i < indices.length; i ++ ) {\n\n\t\t\tlet nex = i + 1;\n\n\t\t\tif ( nex == indices.length ) {\n\n\t\t\t\tnex = 0;\n\n\t\t\t}\n\n\t\t\tn[ 0 ] = n[ 0 ] + ( ( indices[ i ].y - indices[ nex ].y ) * ( indices[ i ].z + indices[ nex ].z ) );\n\t\t\tn[ 1 ] = n[ 1 ] + ( ( indices[ i ].z - indices[ nex ].z ) * ( indices[ i ].x + indices[ nex ].x ) );\n\t\t\tn[ 2 ] = n[ 2 ] + ( ( indices[ i ].x - indices[ nex ].x ) * ( indices[ i ].y + indices[ nex ].y ) );\n\n\t\t}\n\n\t\tlet b = new Vector3( n[ 0 ], n[ 1 ], n[ 2 ] );\n\t\treturn ( b.normalize() );\n\n\t}\n\n\tto_2d( p, n ) {\n\n\t\tp = new Vector3( p.x, p.y, p.z );\n\t\tlet x3 = new Vector3( 1.1, 1.1, 1.1 );\n\t\tif ( x3.distanceTo( n ) < 0.01 ) {\n\n\t\t\tx3.add( new Vector3( 1.0, 2.0, 3.0 ) );\n\n\t\t}\n\n\t\tlet tmp = x3.dot( n );\n\t\tlet tmp2 = n.clone();\n\t\ttmp2.multiplyScalar( tmp );\n\t\tx3.sub( tmp2 );\n\t\tx3.normalize();\n\t\tlet y3 = n.clone();\n\t\ty3.cross( x3 );\n\t\tlet x = p.dot( x3 );\n\t\tlet y = p.dot( y3 );\n\t\tlet re = { x: x, y: y };\n\t\treturn re;\n\n\t}\n\n}\n","import { LineParser } from '../geometry/LineParser.js';\nimport { PointParser } from '../geometry/PointParser.js';\nimport { TriangleParser } from '../geometry/TriangleParser.js';\n\nexport class ChunkParser {\n\n\tconstructor() {\n\n\t\tthis.matrix = null;\n\t\tthis.chunkSize = 2000;\n\n\t\tthis.lods = [];\n\t\tthis.objectColors = {};\n\t\tthis.surfaceColors = {};\n\n\t\tthis.onchunkload = null;\n\t\tthis.onComplete = null;\n\n\t}\n\n\tparse( data ) {\n\n\t\tlet i = 0;\n\n\t\tconst geometryParsers = [\n\t\t\tnew TriangleParser( data, Object.keys( data.CityObjects ), this.objectColors ),\n\t\t\tnew LineParser( data, Object.keys( data.CityObjects ), this.objectColors ),\n\t\t\tnew PointParser( data, Object.keys( data.CityObjects ), this.objectColors )\n\t\t];\n\n\t\tfor ( const objectId in data.CityObjects ) {\n\n\t\t\tconst cityObject = data.CityObjects[ objectId ];\n\n\t\t\tif ( cityObject.geometry && cityObject.geometry.length > 0 ) {\n\n\t\t\t\tfor ( let geom_i = 0; geom_i < cityObject.geometry.length; geom_i ++ ) {\n\n\t\t\t\t\tfor ( const geometryParser of geometryParsers ) {\n\n\t\t\t\t\t\tgeometryParser.lods = this.lods;\n\t\t\t\t\t\tgeometryParser.parseGeometry( cityObject.geometry[ geom_i ], objectId, geom_i );\n\t\t\t\t\t\tthis.lods = geometryParser.lods;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( i ++ > this.chunkSize ) {\n\n\t\t\t\tfor ( const geometryParser of geometryParsers ) {\n\n\t\t\t\t\tthis.returnObjects( geometryParser, data );\n\n\t\t\t\t\tgeometryParser.clean();\n\n\t\t\t\t}\n\n\t\t\t\ti = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( const geometryParser of geometryParsers ) {\n\n\t\t\t// TODO: fix the \"finished\" flag here - probably better be a\n\t\t\t// different callback\n\t\t\tthis.returnObjects( geometryParser, data );\n\n\t\t\tgeometryParser.clean();\n\n\t\t}\n\n\t\t// TODO: this needs some fix - probably a common configuration class\n\t\t// shared between the parsers\n\t\tthis.objectColors = geometryParsers[ 0 ].objectColors;\n\t\tthis.surfaceColors = geometryParsers[ 0 ].surfaceColors;\n\n\t\tif ( this.onComplete ) {\n\n\t\t\tthis.onComplete();\n\n\t\t}\n\n\t}\n\n\treturnObjects( parser, data ) {\n\n\t\tif ( parser.geomData.count() > 0 ) {\n\n\t\t\tthis.onchunkload( parser.geomData.getVertices( data.vertices ),\n\t\t\t\t\t\t\t  parser.geomData.toObject(),\n\t\t\t\t\t\t\t  parser.lods,\n\t\t\t\t\t\t\t  parser.objectColors,\n\t\t\t\t\t\t\t  parser.surfaceColors );\n\n\t\t}\n\n\t}\n\n}\n","export class AttributeEvaluator {\n\n\tconstructor( citymodel, attributeName, includeNulls = false, checkParents = true, checkChildren = true ) {\n\n\t\tthis.citymodel = citymodel;\n\t\tthis.attributeName = attributeName;\n\n\t\tthis.includeNulls = includeNulls;\n\t\tthis.checkParents = checkParents;\n\t\tthis.checkChildren = checkChildren;\n\n\t\tthis.allValues = [];\n\t\tthis.uniqueValues = [];\n\n\t}\n\n\tgetAttributeValue( objectId, checkParent = true, checkChildren = true ) {\n\n\t\tconst cityobject = this.citymodel.CityObjects[ objectId ];\n\n\t\tif ( cityobject.attributes && cityobject.attributes[ this.attributeName ] !== undefined ) {\n\n\t\t\treturn cityobject.attributes[ this.attributeName ];\n\n\t\t}\n\n\t\tif ( checkParent && cityobject.parents ) {\n\n\t\t\tfor ( const parentId of cityobject.parents ) {\n\n\t\t\t\treturn this.getAttributeValue( parentId, true, false );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( checkChildren && cityobject.children || cityobject.members ) {\n\n\t\t\tconst children = cityobject.children ? cityobject.children : cityobject.members;\n\n\t\t\tfor ( const childId of children ) {\n\n\t\t\t\treturn this.getAttributeValue( childId, false, true );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tgetAllValues() {\n\n\t\tif ( this.allValues.length == 0 ) {\n\n\t\t\tconst allValues = [];\n\n\t\t\tfor ( const objId in this.citymodel.CityObjects ) {\n\n\t\t\t\tallValues.push( String( this.getAttributeValue( objId, this.checkParents, this.checkChildren ) ) );\n\n\t\t\t}\n\n\t\t\tthis.allValues = allValues;\n\n\t\t}\n\n\t\treturn this.allValues;\n\n\t}\n\n\tgetUniqueValues() {\n\n\t\tif ( this.uniqueValues.length == 0 ) {\n\n\t\t\tconst uniqueValues = new Set( this.getAllValues() );\n\n\t\t\tif ( ! this.includeNulls ) {\n\n\t\t\t\tuniqueValues.delete( null );\n\n\t\t\t}\n\n\t\t\t// This is a weird hack, but it's because sorting of keys is different\n\t\t\t// than sorting the values in any logical way. So we create a fake\n\t\t\t// object and just take its keys with the order that JS decides to\n\t\t\t// sort them.\n\n\t\t\tconst colors = {};\n\n\t\t\tfor ( const value of [ ...uniqueValues ].sort() ) {\n\n\t\t\t\tcolors[ value ] = '';\n\n\t\t\t}\n\n\t\t\tthis.uniqueValues = Object.keys( colors );\n\n\t\t}\n\n\t\treturn this.uniqueValues;\n\n\t}\n\n\tcreateColors() {\n\n\t\tconst uniqueValues = this.getUniqueValues();\n\t\tconst colors = {};\n\n\t\tfor ( const value of uniqueValues ) {\n\n\t\t\tcolors[ value ] = Math.floor( Math.random() * 0xffffff );\n\n\t\t}\n\n\t\treturn colors;\n\n\t}\n\n}\n","import { Texture } from \"three\";\nimport { sRGBEncoding } from \"three\";\nimport { ShaderLib } from \"three\";\nimport { RepeatWrapping } from \"three\";\nimport { TextureLoader } from \"three\";\nimport { CityObjectsMaterial } from \"../materials/CityObjectsMaterial.js\";\n\nexport class TextureManager {\n\n\tconstructor( citymodel ) {\n\n\t\tif ( citymodel.appearance && citymodel.appearance.textures ) {\n\n\t\t\tthis.cityTextures = citymodel.appearance.textures;\n\n\t\t} else {\n\n\t\t\tthis.cityTextures = [];\n\n\t\t}\n\n\t\tthis.textures = [];\n\t\tthis.materials = [];\n\n\t\tthis.needsUpdate = false;\n\t\tthis.onChange = null;\n\n\t\tthis.loadFromUrl();\n\n\t}\n\n\tget totalTextures() {\n\n\t\treturn this.cityTextures.length;\n\n\t}\n\n\tget resolvedTextures() {\n\n\t\treturn this.textures.filter( t => t ).length;\n\n\t}\n\n\tgetMaterials( baseMaterial ) {\n\n\t\tif ( this.materials.length === 0 || this.needsUpdate ) {\n\n\t\t\tconst materials = [];\n\n\t\t\tfor ( let i = 0; i < this.cityTextures.length; i ++ ) {\n\n\t\t\t\tif ( this.textures[ i ] ) {\n\n\t\t\t\t\tconst mat = new CityObjectsMaterial( ShaderLib.lambert, {\n\t\t\t\t\t\tobjectColors: baseMaterial.objectColors,\n\t\t\t\t\t\tsurfaceColors: baseMaterial.surfaceColors\n\t\t\t\t\t} );\n\n\t\t\t\t\tmat.uniforms.cityTexture.value = this.textures[ i ];\n\t\t\t\t\tmat.needsUpdate = true;\n\n\t\t\t\t\tmaterials.push( mat );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterials.push( baseMaterial );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( const mat of this.materials ) {\n\n\t\t\t\tif ( mat !== baseMaterial ) {\n\n\t\t\t\t\tmat.dispose();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.materials = materials;\n\n\t\t\tthis.needsUpdate = false;\n\n\t\t}\n\n\t\treturn [ ...this.materials, baseMaterial ];\n\n\t}\n\n\tsetTextureFromUrl( i, url ) {\n\n\t\tconst context = this;\n\n\t\tnew TextureLoader().load( url, ( tex => {\n\n\t\t\ttex.encoding = sRGBEncoding;\n\t\t\ttex.wrapS = RepeatWrapping;\n\t\t\ttex.wrapT = RepeatWrapping;\n\n\t\t\tcontext.textures[ i ] = tex;\n\n\t\t\tthis.needsUpdate = true;\n\t\t\tif ( this.onChange ) {\n\n\t\t\t\tthis.onChange();\n\n\t\t\t}\n\n\t\t} ) );\n\n\t}\n\n\tloadFromUrl() {\n\n\t\tthis.textures = [];\n\n\t\tfor ( const [ i, texture ] of this.cityTextures.entries() ) {\n\n\t\t\tthis.setTextureFromUrl( i, texture.image );\n\n\t\t}\n\n\t}\n\n\tsetTextureFromFile( file ) {\n\n\t\tconst context = this;\n\n\t\tfor ( const [ i, texture ] of this.cityTextures.entries() ) {\n\n\t\t\tif ( texture.image.includes( file.name ) ) {\n\n\t\t\t\tconst reader = new FileReader();\n\n\t\t\t\treader.onload = event => {\n\n\t\t\t\t\tconst img = new Image();\n\n\t\t\t\t\timg.onload = evt => {\n\n\t\t\t\t\t\tconst tex = new Texture( evt.target );\n\n\t\t\t\t\t\ttex.encoding = sRGBEncoding;\n\t\t\t\t\t\ttex.wrapS = RepeatWrapping;\n\t\t\t\t\t\ttex.wrapT = RepeatWrapping;\n\t\t\t\t\t\ttex.needsUpdate = true;\n\n\t\t\t\t\t\tcontext.textures[ i ] = tex;\n\n\t\t\t\t\t\tthis.needsUpdate = true;\n\t\t\t\t\t\tif ( this.onChange ) {\n\n\t\t\t\t\t\t\tthis.onChange();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t};\n\n\t\t\t\t\timg.src = event.target.result;\n\n\t\t\t\t};\n\n\t\t\t\treader.readAsDataURL( file );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n"],"names":[],"version":3,"file":"index.js.map","sourceRoot":"../"}