{"mappings":"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","sources":["src/parsers/helpers/ParserWorker.js","node_modules/regenerator-runtime/runtime.js","src/parsers/helpers/ChunkParser.js","src/parsers/geometry/LineParser.js","src/parsers/geometry/GeometryData.js","src/parsers/geometry/BaseParser.js","src/defaults/colors.js","src/parsers/geometry/PointParser.js","src/parsers/geometry/TriangleParser.js"],"sourcesContent":["import 'regenerator-runtime/runtime.js';\nimport { ChunkParser } from './ChunkParser.js';\n\nonmessage = function ( e ) {\n\n\tconst parser = new ChunkParser();\n\n\tconst props = e.data[ 1 ];\n\n\tif ( props ) {\n\n\t\tif ( props.chunkSize ) {\n\n\t\t\tparser.chunkSize = props.chunkSize;\n\n\t\t}\n\n\t\tif ( props.objectColors ) {\n\n\t\t\tparser.objectColors = props.objectColors;\n\n\t\t}\n\n\t\tif ( props.lods ) {\n\n\t\t\tparser.lods = props.lods;\n\n\t\t}\n\n\t}\n\n\tparser.onchunkload = ( v, geometryData, lods, objectColors, surfaceColors ) => {\n\n\t\tconst vertexArray = new Float32Array( v );\n\t\tconst vertexBuffer = vertexArray.buffer;\n\n\t\tconst msg = {\n\t\t\ttype: \"chunkLoaded\",\n\t\t\tv_buffer: vertexBuffer,\n\t\t\tgeometryData,\n\t\t\tlods,\n\t\t\tobjectColors,\n\t\t\tsurfaceColors\n\t\t};\n\t\tpostMessage( msg, [ vertexBuffer ] );\n\n\t};\n\n\tparser.onComplete = () => {\n\n\t\tthis.postMessage( { type: \"done\" } );\n\n\t};\n\n\tparser.parse( e.data[ 0 ] );\n\n};\n\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, \"constructor\", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n","import { LineParser } from '../geometry/LineParser.js';\nimport { PointParser } from '../geometry/PointParser.js';\nimport { TriangleParser } from '../geometry/TriangleParser.js';\n\nexport class ChunkParser {\n\n\tconstructor() {\n\n\t\tthis.matrix = null;\n\t\tthis.chunkSize = 2000;\n\n\t\tthis.lods = [];\n\t\tthis.objectColors = {};\n\t\tthis.surfaceColors = {};\n\n\t\tthis.onchunkload = null;\n\t\tthis.onComplete = null;\n\n\t}\n\n\tparse( data ) {\n\n\t\tlet i = 0;\n\n\t\tconst geometryParsers = [\n\t\t\tnew TriangleParser( data, Object.keys( data.CityObjects ), this.objectColors ),\n\t\t\tnew LineParser( data, Object.keys( data.CityObjects ), this.objectColors ),\n\t\t\tnew PointParser( data, Object.keys( data.CityObjects ), this.objectColors )\n\t\t];\n\n\t\tfor ( const objectId in data.CityObjects ) {\n\n\t\t\tconst cityObject = data.CityObjects[ objectId ];\n\n\t\t\tif ( cityObject.geometry && cityObject.geometry.length > 0 ) {\n\n\t\t\t\tfor ( let geom_i = 0; geom_i < cityObject.geometry.length; geom_i ++ ) {\n\n\t\t\t\t\tfor ( const geometryParser of geometryParsers ) {\n\n\t\t\t\t\t\tgeometryParser.lods = this.lods;\n\t\t\t\t\t\tgeometryParser.parseGeometry( cityObject.geometry[ geom_i ], objectId, geom_i );\n\t\t\t\t\t\tthis.lods = geometryParser.lods;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( i ++ > this.chunkSize ) {\n\n\t\t\t\tfor ( const geometryParser of geometryParsers ) {\n\n\t\t\t\t\tthis.returnObjects( geometryParser, data );\n\n\t\t\t\t\tgeometryParser.clean();\n\n\t\t\t\t}\n\n\t\t\t\ti = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( const geometryParser of geometryParsers ) {\n\n\t\t\t// TODO: fix the \"finished\" flag here - probably better be a\n\t\t\t// different callback\n\t\t\tthis.returnObjects( geometryParser, data );\n\n\t\t\tgeometryParser.clean();\n\n\t\t}\n\n\t\t// TODO: this needs some fix - probably a common configuration class\n\t\t// shared between the parsers\n\t\tthis.objectColors = geometryParsers[ 0 ].objectColors;\n\t\tthis.surfaceColors = geometryParsers[ 0 ].surfaceColors;\n\n\t\tif ( this.onComplete ) {\n\n\t\t\tthis.onComplete();\n\n\t\t}\n\n\t}\n\n\treturnObjects( parser, data ) {\n\n\t\tif ( parser.geomData.count() > 0 ) {\n\n\t\t\tthis.onchunkload( parser.geomData.getVertices( data.vertices ),\n\t\t\t\t\t\t\t  parser.geomData.toObject(),\n\t\t\t\t\t\t\t  parser.lods,\n\t\t\t\t\t\t\t  parser.objectColors,\n\t\t\t\t\t\t\t  parser.surfaceColors );\n\n\t\t}\n\n\t}\n\n}\n","import { LINES, GeometryData } from './GeometryData.js';\nimport { BaseParser } from './BaseParser.js';\n\nexport class LineParser extends BaseParser {\n\n\tconstructor( json, objectIds, objectColors ) {\n\n\t\tsuper( json, objectIds, objectColors );\n\n\t\tthis.geomData = new GeometryData( LINES );\n\n\t}\n\n\tclean() {\n\n\t\tthis.geomData = new GeometryData( LINES );\n\n\t}\n\n\thandles( geometry ) {\n\n\t\treturn geometry.type == \"MultiLineString\";\n\n\t}\n\n\tparseGeometry( geometry, objectId, geomIdx ) {\n\n\t\tconst semanticSurfaces = geometry.semantics ? geometry.semantics.surfaces : [];\n\n\t\tif ( geometry.type == \"MultiLineString\" ) {\n\n\t\t\tconst cityObj = this.json.CityObjects[ objectId ];\n\n\t\t\tconst idIdx = this.getObjectIdx( objectId );\n\n\t\t\tconst objType = this.getObjectTypeIdx( cityObj.type );\n\n\t\t\tconst lodIdx = this.getLodIndex( cityObj.geometry[ geomIdx ].lod );\n\n\t\t\tconst linestrings = geometry.boundaries;\n\n\t\t\tfor ( let i = 0; i < linestrings.length; i ++ ) {\n\n\t\t\t\tif ( linestrings[ i ].length > 1 ) {\n\n\t\t\t\t\tconst semantics = geometry.semantics ? geometry.semantics.values : [];\n\t\t\t\t\tconst surfaceType = this.getSurfaceTypeIdx( i, semantics, semanticSurfaces );\n\n\t\t\t\t\tconst linestring = linestrings[ i ];\n\n\t\t\t\t\t// Contains the boundary but with the right verticeId\n\t\t\t\t\tfor ( let j = 0; j < linestrings[ i ].length - 1; j ++ ) {\n\n\t\t\t\t\t\tthis.geomData.addVertex( linestring[ j ],\n\t\t\t\t\t\t\tidIdx,\n\t\t\t\t\t\t\tobjType,\n\t\t\t\t\t\t\tsurfaceType,\n\t\t\t\t\t\t\tgeomIdx,\n\t\t\t\t\t\t\ti,\n\t\t\t\t\t\t\tlodIdx );\n\n\t\t\t\t\t\tthis.geomData.addVertex( linestring[ j + 1 ],\n\t\t\t\t\t\t\tidIdx,\n\t\t\t\t\t\t\tobjType,\n\t\t\t\t\t\t\tsurfaceType,\n\t\t\t\t\t\t\tgeomIdx,\n\t\t\t\t\t\t\ti,\n\t\t\t\t\t\t\tlodIdx );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n","// Geometry types\nexport const POINTS = 0;\nexport const LINES = 1;\nexport const TRIANGLES = 2;\n\nexport class GeometryData {\n\n\tconstructor( geometryType ) {\n\n\t\tthis.geometryType = geometryType;\n\n\t\tthis.vertexIds = [];\n\t\tthis.objectIds = [];\n\t\tthis.objectTypes = [];\n\t\tthis.semanticSurfaces = [];\n\t\tthis.geometryIds = [];\n\t\tthis.boundaryIds = [];\n\t\tthis.lodIds = [];\n\t\tthis.materials = {};\n\t\tthis.textures = {};\n\n\t}\n\n\tappendMaterial( theme, v ) {\n\n\t\tif ( ! ( theme in this.materials ) ) {\n\n\t\t\tthis.materials[ theme ] = [];\n\n\t\t}\n\n\t\tconst themeArray = this.materials[ theme ];\n\n\t\tfor ( let i = themeArray.length; i < this.count() - 1; i ++ ) {\n\n\t\t\tthemeArray.push( - 1 );\n\n\t\t}\n\n\t\tthis.materials[ theme ].push( v );\n\n\t}\n\n\tappendTexture( theme, values ) {\n\n\t\tif ( ! ( theme in this.textures ) ) {\n\n\t\t\tthis.textures[ theme ] = {\n\t\t\t\tindex: [],\n\t\t\t\tuvs: []\n\t\t\t};\n\n\t\t}\n\n\t\tconst themeObject = this.textures[ theme ];\n\n\t\tfor ( let i = themeObject.index.length; i < this.count() - 1; i ++ ) {\n\n\t\t\tthemeObject.index.push( - 1 );\n\t\t\tthemeObject.uvs.push( [ 0, 0 ] );\n\n\t\t}\n\n\t\tthemeObject.index.push( values.index );\n\t\tthemeObject.uvs.push( values.uvs );\n\n\t}\n\n\taddVertex( vertexId, objectId, objectType, surfaceType, geometryIdx, boundaryIdx, lodIdx, material, texture ) {\n\n\t\tthis.vertexIds.push( vertexId );\n\t\tthis.objectIds.push( objectId );\n\t\tthis.objectTypes.push( objectType );\n\t\tthis.semanticSurfaces.push( surfaceType );\n\t\tthis.geometryIds.push( geometryIdx );\n\t\tthis.boundaryIds.push( boundaryIdx );\n\t\tthis.lodIds.push( lodIdx );\n\n\t\tif ( material ) {\n\n\t\t\tconst context = this;\n\n\t\t\tObject.entries( material ).forEach( entry => {\n\n\t\t\t\tconst [ theme, value ] = entry;\n\n\t\t\t\tcontext.appendMaterial( theme, value );\n\n\t\t\t} );\n\n\t\t}\n\n\t\tif ( texture ) {\n\n\t\t\tconst context = this;\n\n\t\t\tObject.entries( texture ).forEach( entry => {\n\n\t\t\t\tconst [ theme, value ] = entry;\n\n\t\t\t\tcontext.appendTexture( theme, value );\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\tcompleteMaterials() {\n\n\t\tfor ( const theme in this.materials ) {\n\n\t\t\tconst themeArray = this.materials[ theme ];\n\n\t\t\tfor ( let i = themeArray.length; i < this.count(); i ++ ) {\n\n\t\t\t\tthemeArray.push( - 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcompleteTextures() {\n\n\t\tfor ( const theme in this.textures ) {\n\n\t\t\tconst themeObject = this.textures[ theme ];\n\n\t\t\tfor ( let i = themeObject.index.length; i < this.count(); i ++ ) {\n\n\t\t\t\tthemeObject.index.push( - 1 );\n\t\t\t\tthemeObject.uvs.push( [ 0, 0 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcount() {\n\n\t\treturn this.vertexIds.length;\n\n\t}\n\n\tgetVertices( vertexList ) {\n\n\t\tlet vertices = [];\n\n\t\tfor ( const vertexIndex of this.vertexIds ) {\n\n\t\t\tconst vertex = vertexList[ vertexIndex ];\n\n\t\t\tvertices.push( ...vertex );\n\n\t\t}\n\n\t\treturn vertices;\n\n\t}\n\n\ttoObject() {\n\n\t\tthis.completeMaterials();\n\t\tthis.completeTextures();\n\n\t\treturn {\n\t\t\tgeometryType: this.geometryType,\n\t\t\tobjectIds: this.objectIds,\n\t\t\tobjectType: this.objectTypes,\n\t\t\tsemanticSurfaces: this.semanticSurfaces,\n\t\t\tgeometryIds: this.geometryIds,\n\t\t\tboundaryIds: this.boundaryIds,\n\t\t\tlodIds: this.lodIds,\n\t\t\tmaterials: this.materials,\n\t\t\ttextures: this.textures\n\t\t};\n\n\t}\n\n\tsetObjectId( objectId ) {\n\n\t\tfor ( let i = 0; i < this.objectIds.length; i ++ ) {\n\n\t\t\tthis.objectIds[ i ] = objectId;\n\n\t\t}\n\n\t}\n\n\n\tsetObjectType( objectType ) {\n\n\t\tfor ( let i = 0; i < this.objectTypes.length; i ++ ) {\n\n\t\t\tthis.objectTypes[ i ] = objectType;\n\n\t\t}\n\n\t}\n\n\tsetGeometryIdx( geometryIdx ) {\n\n\t\tfor ( let i = 0; i < this.geometryIds.length; i ++ ) {\n\n\t\t\tthis.geometryIds[ i ] = geometryIdx;\n\n\t\t}\n\n\t}\n\n\tmerge( otherGeomData ) {\n\n\t\tif ( otherGeomData.geometryType != this.geometryType ) {\n\n\t\t\tconsole.warn( \"Merging different types of geometry data!\" );\n\n\t\t}\n\n\t\tthis.vertexIds.concat( this.otherGeomData.vertexId );\n\t\tthis.objectIds.concat( this.otherGeomData.objectId );\n\t\tthis.objectTypes.concat( this.otherGeomData.objectType );\n\t\tthis.semanticSurfaces.concat( this.otherGeomData.surfaceType );\n\t\tthis.geometryIds.concat( this.otherGeomData.geometryIdx );\n\t\tthis.boundaryIds.concat( this.otherGeomData.boundaryIdx );\n\t\tthis.lodIds.concat( this.otherGeomData.lodIdx );\n\n\t}\n\n}\n","import { defaultSemanticsColors } from '../../defaults/colors.js';\n\nexport class BaseParser {\n\n\tconstructor( json, objectIds, objectColors ) {\n\n\t\tthis.json = json;\n\n\t\tthis.objectIds = objectIds;\n\t\tthis.objectColors = objectColors;\n\t\tthis.surfaceColors = defaultSemanticsColors;\n\t\tthis.lods = [];\n\n\t}\n\n\tclean() { }\n\n\tparseGeometry( geometry, objectId, geomIdx ) {}\n\n\tgetObjectIdx( objectId ) {\n\n\t\treturn this.objectIds.indexOf( objectId );\n\n\t}\n\n\tgetObjectTypeIdx( cityObjectTypeName ) {\n\n\t\tlet objType = Object.keys( this.objectColors ).indexOf( cityObjectTypeName );\n\n\t\tif ( objType < 0 ) {\n\n\t\t\tobjType = Object.keys( this.objectColors ).length;\n\t\t\tthis.objectColors[ cityObjectTypeName ] = Math.floor( Math.random() * 0xffffff );\n\n\t\t}\n\n\t\treturn objType;\n\n\t}\n\n\tgetSurfaceTypeIdx( idx, semantics, surfaces ) {\n\n\t\tlet surfaceType = - 1;\n\t\tif ( semantics.length > 0 ) {\n\n\t\t\tconst surface = surfaces[ semantics[ idx ] ];\n\n\t\t\tif ( surface ) {\n\n\t\t\t\tsurfaceType = Object.keys( this.surfaceColors ).indexOf( surface.type );\n\n\t\t\t\tif ( surfaceType < 0 ) {\n\n\t\t\t\t\tsurfaceType = Object.keys( this.surfaceColors ).length;\n\t\t\t\t\tthis.surfaceColors[ surface.type ] = Math.floor( Math.random() * 0xffffff );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn surfaceType;\n\n\t}\n\n\tgetSurfaceMaterials( idx, material ) {\n\n\t\tconst pairs = Object.entries( material ).map( mat => {\n\n\t\t\tconst [ theme, obj ] = mat;\n\n\t\t\tif ( obj.values ) {\n\n\t\t\t\treturn [ theme, obj.values[ idx ] ];\n\n\t\t\t} else if ( obj.value !== undefined ) {\n\n\t\t\t\treturn [ theme, obj.value ];\n\n\t\t\t} else {\n\n\t\t\t\treturn [ theme, - 1 ];\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn Object.fromEntries( pairs );\n\n\t}\n\n\tgetTextureData( surfaceIndex, vertexIndex, holes, texture ) {\n\n\t\tif ( this.json.appearance && this.json.appearance[ 'vertices-texture' ] ) {\n\n\t\t\tconst textureVertices = this.json.appearance[ 'vertices-texture' ];\n\n\t\t\tconst pairs = Object.entries( texture ).map( tex => {\n\n\t\t\t\tconst [ theme, obj ] = tex;\n\n\t\t\t\tif ( obj.values ) {\n\n\t\t\t\t\tconst activeHoles = holes.filter( v => v <= vertexIndex );\n\n\t\t\t\t\tconst ringId = activeHoles.length;\n\t\t\t\t\tconst vId = ringId ? vertexIndex - activeHoles[ activeHoles.length - 1 ] : vertexIndex;\n\n\t\t\t\t\t// TODO: This is very delicate\n\t\t\t\t\tconst data = obj.values[ surfaceIndex ];\n\n\t\t\t\t\tif ( data[ 0 ][ 0 ] !== null ) {\n\n\t\t\t\t\t\tconst uvs = textureVertices[ data[ ringId ][ vId + 1 ] ];\n\n\t\t\t\t\t\treturn [ theme, { index: data[ 0 ][ 0 ], uvs } ];\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\treturn [ theme, { index: - 1, uvs: [ 0, 0 ] } ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn [ theme, { index: - 1, uvs: [ 0, 0 ] } ];\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn Object.fromEntries( pairs );\n\n\t\t}\n\n\t\treturn undefined;\n\n\t}\n\n\tgetLodIndex( lod ) {\n\n\t\tif ( lod === undefined ) {\n\n\t\t\treturn - 1;\n\n\t\t}\n\n\t\tconst lodIdx = this.lods.indexOf( lod );\n\n\t\tif ( lodIdx < 0 ) {\n\n\t\t\tconst newIdx = this.lods.length;\n\t\t\tthis.lods.push( lod );\n\t\t\treturn newIdx;\n\n\t\t}\n\n\t\treturn lodIdx;\n\n\t}\n\n}\n","export const defaultObjectColors = {\n\t\"Building\": 0x7497df,\n\t\"BuildingPart\": 0x7497df,\n\t\"BuildingInstallation\": 0x7497df,\n\t\"Bridge\": 0x999999,\n\t\"BridgePart\": 0x999999,\n\t\"BridgeInstallation\": 0x999999,\n\t\"BridgeConstructionElement\": 0x999999,\n\t\"CityObjectGroup\": 0xffffb3,\n\t\"CityFurniture\": 0xcc0000,\n\t\"GenericCityObject\": 0xcc0000,\n\t\"LandUse\": 0xffffb3,\n\t\"PlantCover\": 0x39ac39,\n\t\"Railway\": 0x000000,\n\t\"Road\": 0x999999,\n\t\"SolitaryVegetationObject\": 0x39ac39,\n\t\"TINRelief\": 0xffdb99,\n\t\"TransportSquare\": 0x999999,\n\t\"Tunnel\": 0x999999,\n\t\"TunnelPart\": 0x999999,\n\t\"TunnelInstallation\": 0x999999,\n\t\"WaterBody\": 0x4da6ff\n};\n\nexport const defaultSemanticsColors = {\n\t\"GroundSurface\": 0x999999,\n\t\"WallSurface\": 0xffffff,\n\t\"RoofSurface\": 0xff0000,\n\t\"TrafficArea\": 0x6e6e6e,\n\t\"AuxiliaryTrafficArea\": 0x2c8200,\n\t\"Window\": 0x0059ff,\n\t\"Door\": 0x640000\n};\n","import { POINTS, GeometryData } from './GeometryData.js';\nimport { BaseParser } from './BaseParser.js';\n\nexport class PointParser extends BaseParser {\n\n\tconstructor( json, objectIds, objectColors ) {\n\n\t\tsuper( json, objectIds, objectColors );\n\n\t\tthis.geomData = new GeometryData( POINTS );\n\n\t}\n\n\tclean() {\n\n\t\tthis.geomData = new GeometryData( POINTS );\n\n\t}\n\n\thandles( geometry ) {\n\n\t\treturn geometry.type == \"MultiPoint\";\n\n\t}\n\n\tparseGeometry( geometry, objectId, geomIdx ) {\n\n\t\tconst semanticSurfaces = geometry.semantics ? geometry.semantics.surfaces : [];\n\n\t\tif ( geometry.type == \"MultiPoint\" ) {\n\n\t\t\tconst cityObj = this.json.CityObjects[ objectId ];\n\n\t\t\tconst idIdx = this.getObjectIdx( objectId );\n\n\t\t\tconst objType = this.getObjectTypeIdx( cityObj.type );\n\n\t\t\tconst lodIdx = this.getLodIndex( cityObj.geometry[ geomIdx ].lod );\n\n\t\t\tconst points = geometry.boundaries;\n\n\t\t\tfor ( let i = 0; i < points.length; i ++ ) {\n\n\t\t\t\tconst semantics = geometry.semantics ? geometry.semantics.values : [];\n\t\t\t\tconst surfaceType = this.getSurfaceTypeIdx( i, semantics, semanticSurfaces );\n\n\t\t\t\tthis.geomData.addVertex( points[ i ],\n\t\t\t\t\tidIdx,\n\t\t\t\t\tobjType,\n\t\t\t\t\tsurfaceType,\n\t\t\t\t\tgeomIdx,\n\t\t\t\t\ti,\n\t\t\t\t\tlodIdx );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n","import {\n\tVector3\n} from 'three';\nimport earcut from 'earcut';\n\nimport { TRIANGLES, GeometryData } from './GeometryData.js';\nimport { BaseParser } from './BaseParser.js';\n\nexport class TriangleParser extends BaseParser {\n\n\tconstructor( json, objectIds, objectColors, vertices ) {\n\n\t\tsuper( json, objectIds, objectColors );\n\n\t\tif ( vertices ) {\n\n\t\t\tthis.vertices = vertices;\n\n\t\t} else {\n\n\t\t\tthis.vertices = this.json.vertices;\n\n\t\t}\n\n\t\tthis.geomData = new GeometryData( TRIANGLES );\n\n\t}\n\n\tclean() {\n\n\t\tthis.geomData = new GeometryData( TRIANGLES );\n\n\t}\n\n\t/**\n\t * Flattens the given geometry, meaning that a Solid or MultiSolid will be\n\t * basically converted to a MultiSuface\n\t */\n\tflattenGeometry( geometry ) {\n\n\t\tconst geometryType = geometry.type;\n\n\t\tif ( geometryType == \"MultiSurface\" || geometryType == \"CompositeSurface\" ) {\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tif ( geometryType == \"Solid\" ) {\n\n\t\t\tconst newGeometry = Object.assign( {}, geometry );\n\n\t\t\tnewGeometry.boundaries = geometry.boundaries.flat( 1 );\n\n\t\t\tif ( geometry.semantics ) {\n\n\t\t\t\tnewGeometry.semantics.values = geometry.semantics.values.flat( 1 );\n\n\t\t\t}\n\n\t\t\tif ( geometry.material ) {\n\n\t\t\t\tfor ( const theme in geometry.material ) {\n\n\t\t\t\t\tnewGeometry.material[ theme ].values = geometry.material[ theme ].values.flat( 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( geometry.texture ) {\n\n\t\t\t\tfor ( const theme in geometry.texture ) {\n\n\t\t\t\t\tnewGeometry.texture[ theme ].values = geometry.texture[ theme ].values.flat( 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn newGeometry;\n\n\t\t}\n\n\t\tif ( geometryType == \"MultiSolid\" || geometryType == \"CompositeSolid\" ) {\n\n\t\t\tconst newGeometry = Object.assign( {}, geometry );\n\n\t\t\tnewGeometry.boundaries = geometry.boundaries.flat( 2 );\n\n\t\t\tif ( geometry.semantics ) {\n\n\t\t\t\tnewGeometry.semantics.values = geometry.semantics.values.flat( 2 );\n\n\t\t\t}\n\n\t\t\tif ( geometry.material ) {\n\n\t\t\t\tfor ( const theme in geometry.material ) {\n\n\t\t\t\t\tnewGeometry.material[ theme ].values = geometry.material[ theme ].values.flat( 2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( geometry.texture ) {\n\n\t\t\t\tfor ( const theme in geometry.texture ) {\n\n\t\t\t\t\tnewGeometry.texture[ theme ].values = geometry.texture[ theme ].values.flat( 2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn newGeometry;\n\n\t\t}\n\n\t}\n\n\tparseGeometry( geometry, objectId, geomIdx ) {\n\n\t\tconst cityObj = this.json.CityObjects[ objectId ];\n\n\t\tconst idIdx = cityObj ? this.getObjectIdx( objectId ) : - 1;\n\t\tconst objType = cityObj ? this.getObjectTypeIdx( cityObj.type ) : - 1;\n\t\tconst lodIdx = this.getLodIndex( geometry.lod );\n\n\t\t// We flatten the geometry to a MultiSurface, basically, so that it's\n\t\t// easily parsable.\n\t\tconst flatGeometry = this.flattenGeometry( geometry );\n\n\t\tif ( flatGeometry ) {\n\n\t\t\tthis.parseShell( flatGeometry, idIdx, objType, geomIdx, lodIdx );\n\n\t\t}\n\n\n\t}\n\n\tparseShell( geometry, idIdx, objType, geomIdx, lodIdx ) {\n\n\t\tconst boundaries = geometry.boundaries;\n\t\tconst semantics = geometry.semantics ? geometry.semantics.values : [];\n\t\tconst surfaces = geometry.semantics ? geometry.semantics.surfaces : [];\n\t\tconst material = geometry.material ? geometry.material : {};\n\t\tconst texture = geometry.texture ? geometry.texture : {};\n\n\t\t// Contains the boundary but with the right verticeId\n\t\tfor ( let i = 0; i < boundaries.length; i ++ ) {\n\n\t\t\tlet boundary = [];\n\t\t\tlet holes = [];\n\n\t\t\tconst surfaceType = this.getSurfaceTypeIdx( i, semantics, surfaces );\n\t\t\tconst materialValue = this.getSurfaceMaterials( i, material );\n\n\t\t\tfor ( let j = 0; j < boundaries[ i ].length; j ++ ) {\n\n\t\t\t\tif ( boundary.length > 0 ) {\n\n\t\t\t\t\tholes.push( boundary.length );\n\n\t\t\t\t}\n\n\t\t\t\t// const new_boundary = this.extractLocalIndices( geom, boundaries[ i ][ j ], vertices, json );\n\t\t\t\t// boundary.push( ...new_boundary );\n\t\t\t\tboundary.push( ...boundaries[ i ][ j ] );\n\n\t\t\t}\n\n\t\t\tif ( boundary.length == 3 ) {\n\n\t\t\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\t\t\tthis.geomData.addVertex( boundary[ n ],\n\t\t\t\t\t\t\t\t\t\t\t idIdx,\n\t\t\t\t\t\t\t\t\t\t\t objType,\n\t\t\t\t\t\t\t\t\t\t\t surfaceType,\n\t\t\t\t\t\t\t\t\t\t\t geomIdx,\n\t\t\t\t\t\t\t\t\t\t\t i,\n\t\t\t\t\t\t\t\t\t\t\t lodIdx,\n\t\t\t\t\t\t\t\t\t\t\t materialValue,\n\t\t\t\t\t\t\t\t\t\t\t this.getTextureData( i, n, holes, texture ) );\n\n\t\t\t\t}\n\n\n\t\t\t} else if ( boundary.length > 3 ) {\n\n\t\t\t\t//create list of points\n\t\t\t\tlet pList = [];\n\t\t\t\tfor ( let k = 0; k < boundary.length; k ++ ) {\n\n\t\t\t\t\tpList.push( {\n\t\t\t\t\t\tx: this.vertices[ boundary[ k ] ][ 0 ],\n\t\t\t\t\t\ty: this.vertices[ boundary[ k ] ][ 1 ],\n\t\t\t\t\t\tz: this.vertices[ boundary[ k ] ][ 2 ]\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\t//get normal of these points\n\t\t\t\tconst normal = this.getNewellsNormal( pList );\n\n\t\t\t\t//convert to 2d (for triangulation)\n\t\t\t\tlet pv = [];\n\t\t\t\tfor ( let k = 0; k < pList.length; k ++ ) {\n\n\t\t\t\t\tconst re = this.to_2d( pList[ k ], normal );\n\t\t\t\t\tpv.push( re.x );\n\t\t\t\t\tpv.push( re.y );\n\n\t\t\t\t}\n\n\t\t\t\t//triangulate\n\t\t\t\tconst tr = earcut( pv, holes, 2 );\n\n\t\t\t\t// create faces based on triangulation\n\t\t\t\tfor ( let k = 0; k < tr.length; k += 3 ) {\n\n\t\t\t\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\t\t\t\tconst vertex = boundary[ tr[ k + n ] ];\n\n\t\t\t\t\t\tthis.geomData.addVertex( vertex,\n\t\t\t\t\t\t\t\t\t\t\t \t idIdx,\n\t\t\t\t\t\t\t\t\t\t\t\t objType,\n\t\t\t\t\t\t\t\t\t\t\t\t surfaceType,\n\t\t\t\t\t\t\t\t\t\t\t\t geomIdx,\n\t\t\t\t\t\t\t\t\t\t\t\t i,\n\t\t\t\t\t\t\t\t\t\t\t\t lodIdx,\n\t\t\t\t\t\t\t\t\t\t\t\t materialValue,\n\t\t\t\t\t\t\t\t\t\t\t\t this.getTextureData( i, tr[ k + n ], holes, texture ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tgetNewellsNormal( indices ) {\n\n\t\t// find normal with Newell's method\n\t\tlet n = [ 0.0, 0.0, 0.0 ];\n\n\t\tfor ( let i = 0; i < indices.length; i ++ ) {\n\n\t\t\tlet nex = i + 1;\n\n\t\t\tif ( nex == indices.length ) {\n\n\t\t\t\tnex = 0;\n\n\t\t\t}\n\n\t\t\tn[ 0 ] = n[ 0 ] + ( ( indices[ i ].y - indices[ nex ].y ) * ( indices[ i ].z + indices[ nex ].z ) );\n\t\t\tn[ 1 ] = n[ 1 ] + ( ( indices[ i ].z - indices[ nex ].z ) * ( indices[ i ].x + indices[ nex ].x ) );\n\t\t\tn[ 2 ] = n[ 2 ] + ( ( indices[ i ].x - indices[ nex ].x ) * ( indices[ i ].y + indices[ nex ].y ) );\n\n\t\t}\n\n\t\tlet b = new Vector3( n[ 0 ], n[ 1 ], n[ 2 ] );\n\t\treturn ( b.normalize() );\n\n\t}\n\n\tto_2d( p, n ) {\n\n\t\tp = new Vector3( p.x, p.y, p.z );\n\t\tlet x3 = new Vector3( 1.1, 1.1, 1.1 );\n\t\tif ( x3.distanceTo( n ) < 0.01 ) {\n\n\t\t\tx3.add( new Vector3( 1.0, 2.0, 3.0 ) );\n\n\t\t}\n\n\t\tlet tmp = x3.dot( n );\n\t\tlet tmp2 = n.clone();\n\t\ttmp2.multiplyScalar( tmp );\n\t\tx3.sub( tmp2 );\n\t\tx3.normalize();\n\t\tlet y3 = n.clone();\n\t\ty3.cross( x3 );\n\t\tlet x = p.dot( x3 );\n\t\tlet y = p.dot( y3 );\n\t\tlet re = { x: x, y: y };\n\t\treturn re;\n\n\t}\n\n}\n"],"names":[],"version":3,"file":"ParserWorker.bb7c24df.js.map","sourceRoot":"../"}